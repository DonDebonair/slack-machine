{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Slack Machine","text":"<p>Slack Machine is a simple, yet powerful and extendable Slack bot framework. More than just a bot, Slack Machine is a framework that helps you develop your Slack workspace into a ChatOps powerhouse. Slack Machine is built with an intuitive plugin system that lets you build bots quickly, but also allows for easy code organization. A plugin can look as simple as this:</p> <pre><code>from machine.plugins.base import MachineBasePlugin\nfrom machine.plugins.message import Message\nfrom machine.plugins.decorators import respond_to\n\n\nclass DeploymentPlugin(MachineBasePlugin):\n    \"\"\"Deployments\"\"\"\n\n    @respond_to(r\"deploy (?P&lt;application&gt;\\w+) to (?P&lt;environment&gt;\\w+)\")\n    async def deploy(self, msg: Message, application, environment):\n        \"\"\"deploy &lt;application&gt; &lt;environment&gt;: deploy application to target environment\"\"\"\n        await msg.say(f\"Deploying {application} to {environment}\")\n</code></pre>"},{"location":"#breaking-changes","title":"Breaking Changes","text":"<p>Dropped support for Python 3.8 (v0.38.0)</p> <p>As of v0.38.0, support for Python 3.8 has been dropped. Python 3.8 has reached end-of-life on 2024-10-07.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Get started with mininal configuration</li> <li>Built on top of the Slack Events API for smoothly responding   to events in semi real-time. Uses Socket Mode so your bot doesn't   need to be exposed to the internet!</li> <li>Support for rich interactions using the Slack Web API</li> <li>High-level API for maximum convenience when building plugins</li> <li>Low-level API for maximum flexibility</li> <li>Built on top of AsyncIO to ensure good performance by handling   communication with Slack concurrently</li> </ul>"},{"location":"#plugin-api-features","title":"Plugin API features:","text":"<ul> <li>Listen and respond to any regular expression</li> <li>Respond to Slash Commands</li> <li>Capture parts of messages to use as variables in your functions</li> <li>Respond to messages in channels, groups and direct message conversations</li> <li>Respond with reactions</li> <li>Respond in threads</li> <li>Respond with ephemeral messages</li> <li>Send DMs to any user</li> <li>Support for blocks</li> <li>Support for message attachments [Legacy \ud83c\udfda]</li> <li>Support for interactive elements</li> <li>Support for modals</li> <li>Listen and respond to any Slack event supported by the Events API</li> <li>Store and retrieve any kind of data in persistent storage (currently Redis, DynamoDB, SQLite, and in-memory storage   are supported)</li> <li>Schedule actions and messages</li> <li>Emit and listen for events</li> <li>Help texts for Plugins</li> </ul>"},{"location":"#coming-soon","title":"Coming Soon","text":"<ul> <li>Support for shortcuts</li> <li>... and much more</li> </ul>"},{"location":"#examples","title":"Examples","text":"<p>There is an example plugin that shows off many of the features of Slack Machine: Slack Machine Kitchensink Plugin</p>"},{"location":"api/","title":"API Documentation","text":"<p>This is the API documentation of all the classes and functions relevant for Plugin development. The rest of the code deals with the internal workings of Slack Machine and is very much an implementation detail and subject to change. Therefore it is not documented.</p>"},{"location":"api/#plugin-classes","title":"Plugin classes","text":"<p>The following classes form the basis for Plugin development.</p>"},{"location":"api/#machine.plugins.base.MachineBasePlugin","title":"<code>machine.plugins.base.MachineBasePlugin</code>","text":"<p>Base class for all Slack Machine plugins</p> <p>The purpose of this class is two-fold:</p> <ol> <li>It acts as a marker-class so Slack Machine can recognize plugins as such</li> <li>It provides a lot of common functionality and convenience methods for plugins to    interact with channels and users</li> </ol> <p>Attributes:</p> Name Type Description <code>settings</code> <code>CaseInsensitiveDict</code> <p>Slack Machine settings object that contains all settings that         were defined through <code>local_settings.py</code> Plugin developers can use any         settings that are defined by the user, and ask users to add new settings         specifically for their plugin.</p> <code>storage</code> <code>PluginStorage</code> <p>Plugin storage object that allows plugins to store and retrieve data</p> Source code in <code>src/machine/plugins/base.py</code> <pre><code>class MachineBasePlugin:\n    \"\"\"Base class for all Slack Machine plugins\n\n    The purpose of this class is two-fold:\n\n    1. It acts as a marker-class so Slack Machine can recognize plugins as such\n    2. It provides a lot of common functionality and convenience methods for plugins to\n       interact with channels and users\n\n    Attributes:\n        settings: Slack Machine settings object that contains all settings that\n                    were defined through ``local_settings.py`` Plugin developers can use any\n                    settings that are defined by the user, and ask users to add new settings\n                    specifically for their plugin.\n        storage: Plugin storage object that allows plugins to store and retrieve data\n    \"\"\"\n\n    _client: SlackClient\n    storage: PluginStorage\n    settings: CaseInsensitiveDict\n    _fq_name: str\n\n    def __init__(self, client: SlackClient, settings: CaseInsensitiveDict, storage: PluginStorage):\n        self._client = client\n        self.storage = storage\n        self.settings = settings\n        self._fq_name = f\"{self.__module__}.{self.__class__.__name__}\"\n\n    @property\n    def users(self) -&gt; dict[str, User]:\n        \"\"\"Dictionary of all users in the Slack workspace\n\n        Returns:\n            a dictionary of all users in the Slack workspace, where the key is the user id and\n                the value is a [`User`][machine.models.user.User] object\n        \"\"\"\n        return self._client.users\n\n    @property\n    def users_by_email(self) -&gt; dict[str, User]:\n        \"\"\"Dictionary of all users in the Slack workspace by email\n\n        Note:\n            not every user might have an email address in their profile, so this\n            dictionary might not contain all users in the Slack workspace\n\n        Returns:\n            a dictionary of all users in the Slack workspace, where the key is the email and\n                the value is a [`User`][machine.models.user.User] object\n        \"\"\"\n        return self._client.users\n\n    @property\n    def channels(self) -&gt; dict[str, Channel]:\n        \"\"\"List of all channels in the Slack workspace\n\n        This is a list of all channels in the Slack workspace that the bot is aware of. This\n        includes all public channels, all private channels the bot is a member of and all DM\n        channels the bot is a member of.\n\n        Returns:\n            a list of all channels in the Slack workspace, where each channel is a\n                [`Channel`][machine.models.channel.Channel] object\n        \"\"\"\n        return self._client.channels\n\n    @property\n    def web_client(self) -&gt; AsyncWebClient:\n        \"\"\"Slack SDK web client to access the [Slack Web API](https://api.slack.com/web)\n\n        Returns:\n            an instance of [`AsyncWebClient`](https://slack.dev/python-slack-sdk/api-docs/slack_sdk/web/async_client.html#slack_sdk.web.async_client.AsyncWebClient)\n        \"\"\"  # noqa: E501\n        return self._client.web_client\n\n    @property\n    def bot_info(self) -&gt; dict[str, Any]:\n        \"\"\"Information about the bot user in Slack\n\n        This will return a dictionary with information about the bot user in Slack that represents\n        Slack Machine\n\n        Returns:\n            Bot user\n        \"\"\"\n        return self._client.bot_info\n\n    async def init(self) -&gt; None:\n        \"\"\"Initialize plugin\n\n        This method can be implemented by concrete plugin classes. It will be called **once**\n        for each plugin, when that plugin is first loaded. You can refer to settings via\n        `self.settings`, and access storage through `self.storage`, but the Slack client has\n        not been initialized yet, so you cannot send or process messages during initialization.\n        \"\"\"\n        return None\n\n    def find_channel_by_name(self, channel_name: str) -&gt; Channel | None:\n        \"\"\"Find a channel by its name, irrespective of a preceding pound symbol. This does not include DMs.\n\n        Args:\n            channel_name: The name of the channel to retrieve.\n\n        Returns:\n            The channel if found, `None` otherwise.\n        \"\"\"\n        if channel_name.startswith(\"#\"):\n            channel_name = channel_name[1:]\n        for c in self.channels.values():\n            if c.name_normalized and channel_name.lower() == c.name_normalized.lower():\n                return c\n        return None\n\n    def get_user_by_id(self, user_id: str) -&gt; User | None:\n        \"\"\"Get a user by their ID.\n\n        Args:\n            user_id: The ID of the user to retrieve.\n\n        Returns:\n            The user if found, None otherwise.\n        \"\"\"\n        return self.users.get(user_id)\n\n    def get_user_by_email(self, email: str) -&gt; User | None:\n        \"\"\"Get a user by their email address.\n\n        Args:\n            email: The email address of the user to retrieve.\n\n        Returns:\n            The user if found, None otherwise.\n        \"\"\"\n        return self._client.get_user_by_email(email)\n\n    def at(self, user: User) -&gt; str:\n        \"\"\"Create a mention of the provided user\n\n        Create a mention of the provided user in the form of `&lt;@[user_id]&gt;`. This method is\n        convenient when you want to include mentions in your message. This method does not send\n        a message, but should be used together with methods like\n        [`say()`][machine.plugins.base.MachineBasePlugin.say].\n\n        Args:\n            user: user your want to mention\n\n        Returns:\n            user mention\n        \"\"\"\n        return user.fmt_mention()\n\n    async def say(\n        self,\n        channel: Channel | str,\n        text: str | None = None,\n        attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None,\n        blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None,\n        thread_ts: str | None = None,\n        ephemeral_user: User | str | None = None,\n        **kwargs: Any,\n    ) -&gt; AsyncSlackResponse:\n        \"\"\"Send a message to a channel\n\n        Send a message to a channel using the WebAPI. Allows for rich formatting using\n        [blocks] and/or [attachments]. You can provide blocks and attachments as Python dicts or\n        you can use the [convenience classes] that the underlying slack client provides.\n        Can also reply in-thread and send ephemeral messages, visible to only one user.\n        Ephemeral messages and threaded messages are mutually exclusive, and `ephemeral_user`\n        takes precedence over `thread_ts`\n\n        Any extra kwargs you provide, will be passed on directly to the [chat.postMessage] or\n        [chat.postEphemeral] request.\n\n        [attachments]: https://api.slack.com/docs/message-attachments\n        [blocks]: https://api.slack.com/reference/block-kit/blocks\n        [convenience classes]:\n            https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes\n        [chat.postMessage]: https://api.slack.com/methods/chat.postMessage\n        [chat.postEphemeral]: https://api.slack.com/methods/chat.postEphemeral\n\n        Args:\n            channel: [`Channel`][machine.models.channel.Channel] object or id of channel to send\n                message to. Can be public or private (group) channel, or DM channel.\n            text: message text\n            attachments: optional attachments (see [attachments](https://api.slack.com/docs/message-attachments)\n            blocks: optional blocks (see [blocks](https://api.slack.com/reference/block-kit/blocks))\n            thread_ts: optional timestamp of thread, to send a message in that thread\n            ephemeral_user: optional user name or id if the message needs to visible\n                to a specific user only\n\n        Returns:\n            Dictionary deserialized from [chat.postMessage](https://api.slack.com/methods/chat.postMessage) response,\n                or [chat.postEphemeral](https://api.slack.com/methods/chat.postEphemeral) if `ephemeral_user` is set.\n        \"\"\"\n        return await self._client.send(\n            channel,\n            text=text,\n            attachments=attachments,\n            blocks=blocks,\n            thread_ts=thread_ts,\n            ephemeral_user=ephemeral_user,\n            **kwargs,\n        )\n\n    async def say_scheduled(\n        self,\n        when: datetime,\n        channel: Channel | str,\n        text: str,\n        attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None,\n        blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None,\n        thread_ts: str | None = None,\n        **kwargs: Any,\n    ) -&gt; AsyncSlackResponse:\n        \"\"\"Schedule a message to a channel\n\n        This is the scheduled version of [`say()`][machine.plugins.base.MachineBasePlugin.say].\n        It behaves the same, but will send the message at the scheduled time.\n\n        Args:\n            when: when you want the message to be sent, as [`datetime`][datetime.datetime] instance\n            channel: [`Channel`][machine.models.channel.Channel] object or id of channel to send\n                message to. Can be public or private (group) channel, or DM channel.\n            text: message text\n            attachments: optional attachments (see [attachments](https://api.slack.com/docs/message-attachments))\n            blocks: optional blocks (see [blocks](https://api.slack.com/reference/block-kit/blocks))\n            thread_ts: optional timestamp of thread, to send a message in that thread\n        Returns:\n            Dictionary deserialized from [chat.scheduleMessage](https://api.slack.com/methods/chat.scheduleMessage)\n                response.\n        \"\"\"\n        return await self._client.send_scheduled(\n            when,\n            channel,\n            text=text,\n            attachments=attachments,\n            blocks=blocks,\n            thread_ts=thread_ts,\n            **kwargs,\n        )\n\n    async def update(\n        self,\n        channel: Channel | str,\n        ts: str,\n        text: str | None = None,\n        attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None,\n        blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None,\n        ephemeral_user: User | str | None = None,\n        **kwargs: Any,\n    ) -&gt; AsyncSlackResponse:\n        \"\"\"Update an existing message\n\n        Update an existing message using the WebAPI. Allows for rich formatting using\n        [blocks] and/or [attachments]. You can provide blocks and attachments as Python dicts or\n        you can use the [convenience classes] that the underlying slack client provides.\n        Can also update in-thread and ephemeral messages, visible to only one user.\n        Any extra kwargs you provide, will be passed on directly to the [`chat.update`][chat_update] request.\n\n        [attachments]: https://api.slack.com/docs/message-attachments\n        [blocks]: https://api.slack.com/reference/block-kit/blocks\n        [convenience classes]: https://github.com/slackapi/python-slack-sdk/tree/main/slack/web/classes\n        [chat_update]: https://api.slack.com/methods/chat.update\n\n        Args:\n            channel: [`Channel`][machine.models.channel.Channel] object or id of channel to send\n                message to. Can be public or private (group) channel, or DM channel.\n            ts: timestamp of the message to be updated.\n            text: message text\n            attachments: optional attachments (see [attachments](https://api.slack.com/docs/message-attachments))\n            blocks: optional blocks (see [blocks](https://api.slack.com/reference/block-kit/blocks))\n            ephemeral_user: optional user name or id if the message needs to visible\n                to a specific user only\n\n        Returns:\n            Dictionary deserialized from [`chat.update`](https://api.slack.com/methods/chat.update) response\n        \"\"\"\n        return await self._client.update(\n            channel,\n            ts=ts,\n            text=text,\n            attachments=attachments,\n            blocks=blocks,\n            ephemeral_user=ephemeral_user,\n            **kwargs,\n        )\n\n    async def delete(\n        self,\n        channel: Channel | str,\n        ts: str,\n        **kwargs: Any,\n    ) -&gt; AsyncSlackResponse:\n        \"\"\"Delete an existing message\n\n        Delete an existing message using the WebAPI.\n        Any extra kwargs you provide, will be passed on directly to the [`chat.delete`][chat_delete] request.\n\n        [chat_delete]: https://api.slack.com/methods/chat.delete\n\n        Args:\n            channel: [`Channel`][machine.models.channel.Channel] object or id of channel to send\n                message to. Can be public or private (group) channel, or DM channel.\n            ts: timestamp of the message to be deleted.\n\n        Returns:\n            Dictionary deserialized from [`chat.delete`](https://api.slack.com/methods/chat.delete) response\n        \"\"\"\n        return await self._client.delete(\n            channel,\n            ts=ts,\n            **kwargs,\n        )\n\n    async def react(self, channel: Channel | str, ts: str, emoji: str) -&gt; AsyncSlackResponse:\n        \"\"\"React to a message in a channel\n\n        Add a reaction to a message in a channel. What message to react to, is determined by the\n        combination of the channel and the timestamp of the message.\n\n        Args:\n            channel: [`Channel`][machine.models.channel.Channel] object or id of channel to send\n                message to. Can be public or private (group) channel, or DM channel.\n            ts: timestamp of the message to react to\n            emoji: what emoji to react with (should be a string, like 'angel', 'thumbsup', etc.)\n\n        Returns:\n            Dictionary deserialized from [reactions.add](https://api.slack.com/methods/reactions.add) response.\n        \"\"\"\n        return await self._client.react(channel, ts, emoji)\n\n    async def send_dm(\n        self,\n        user: User | str,\n        text: str | None = None,\n        attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None,\n        blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None,\n        **kwargs: Any,\n    ) -&gt; AsyncSlackResponse:\n        \"\"\"Send a Direct Message\n\n        Send a Direct Message to a user by opening a DM channel and sending a message to it. Allows\n        for rich formatting using [blocks] and/or [attachments]. You can provide blocks and\n        attachments as Python dicts or you can use the [convenience classes] that the underlying\n        slack client provides.\n        Any extra kwargs you provide, will be passed on directly to the [chat.postMessage] request.\n\n        [attachments]: https://api.slack.com/docs/message-attachments\n        [blocks]: https://api.slack.com/reference/block-kit/blocks\n        [convenience classes]:\n            https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes\n        [chat.postMessage]: https://api.slack.com/methods/chat.postMessage\n\n        Args:\n            user: [`User`][machine.models.user.User] object or id of user to send DM to.\n            text: message text\n            attachments: optional attachments (see [attachments](https://api.slack.com/docs/message-attachments))\n            blocks: optional blocks (see [blocks](https://api.slack.com/reference/block-kit/blocks))\n\n        Returns:\n            Dictionary deserialized from [chat.postMessage](https://api.slack.com/methods/chat.postMessage) response.\n        \"\"\"\n        return await self._client.send_dm(user, text, attachments=attachments, blocks=blocks, **kwargs)\n\n    async def send_dm_scheduled(\n        self,\n        when: datetime,\n        user: User | str,\n        text: str,\n        attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None,\n        blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None,\n        **kwargs: Any,\n    ) -&gt; AsyncSlackResponse:\n        \"\"\"Schedule a Direct Message\n\n        This is the scheduled version of\n        [`send_dm()`][machine.plugins.base.MachineBasePlugin.send_dm]. It behaves the same, but\n        will send the DM at the scheduled time.\n\n        Args:\n            when: when you want the message to be sent, as [`datetime`][datetime.datetime] instance\n            user: [`User`][machine.models.user.User] object or id of user to send DM to.\n            text: message text\n            attachments: optional attachments (see [attachments](https://api.slack.com/docs/message-attachments))\n            blocks: optional blocks (see [blocks](https://api.slack.com/reference/block-kit/blocks))\n\n        Returns:\n            Dictionary deserialized from [chat.scheduleMessage](https://api.slack.com/methods/chat.scheduleMessage)\n                response.\n        \"\"\"\n        return await self._client.send_dm_scheduled(\n            when, user, text=text, attachments=attachments, blocks=blocks, **kwargs\n        )\n\n    async def open_im(self, users: User | str | list[User | str]) -&gt; str:\n        \"\"\"Open a DM channel with one or more users\n\n        Open a DM channel with one or more users. If the DM channel already exists, the existing channel id\n        will be returned. If the DM channel does not exist, a new channel will be created and the\n        id of the new channel will be returned.\n\n        Args:\n            users: [`User`][machine.models.user.User] object or id of user to open DM with, or a list of user objects\n                or user ids.\n\n        Returns:\n            id of the DM channel\n        \"\"\"\n        return await self._client.open_im(users)\n\n    def emit(self, event: str, **kwargs: Any) -&gt; None:\n        \"\"\"Emit an event\n\n        Emit an event that plugins can listen for. You can include arbitrary data as keyword\n        arguments.\n\n        Args:\n            event: name of the event\n            **kwargs: any data you want to emit with the event\n        \"\"\"\n        ee.emit(event, self, **kwargs)\n\n    async def pin_message(self, channel: Channel | str, ts: str) -&gt; AsyncSlackResponse:\n        \"\"\"Pin message\n\n        Pin a message in a channel\n\n        Args:\n            channel: channel to pin the message in\n            ts: timestamp of the message to pin\n\n        Returns:\n            Dictionary deserialized from [pins.add](https://api.slack.com/methods/pins.add) response.\n        \"\"\"\n        return await self._client.pin_message(channel, ts)\n\n    async def unpin_message(self, channel: Channel | str, ts: str) -&gt; AsyncSlackResponse:\n        \"\"\"Unpin message\n\n        Unpin a message that was previously pinned in a channel\n\n        Args:\n            channel: channel where the message is pinned that needs to be unpinned\n            ts: timestamp of the message to unpin\n\n        Returns:\n            Dictionary deserialized from [pins.remove](https://api.slack.com/methods/pins.remove) response.\n        \"\"\"\n        return await self._client.unpin_message(channel, ts)\n\n    async def set_topic(self, channel: Channel | str, topic: str, **kwargs: Any) -&gt; AsyncSlackResponse:\n        \"\"\"Set channel topic\n\n        Set or update topic for the channel\n\n        Args:\n            channel: channel where topic needs to be set or updated\n            topic: topic for the channel (slack does not support formatting for topics)\n\n        Returns:\n            Dictionary deserialized from [conversations.setTopic](https://api.slack.com/methods/conversations.setTopic)\n                response.\n        \"\"\"\n        return await self._client.set_topic(channel, topic, **kwargs)\n\n    async def open_modal(self, trigger_id: str, view: dict | View, **kwargs: Any) -&gt; AsyncSlackResponse:\n        \"\"\"Open a modal dialog\n\n        Open a modal dialog in response to a user action. The modal dialog can be used to collect\n        information from the user, or to display information to the user.\n\n        Args:\n            trigger_id: trigger id is provided by Slack when a user action is performed, such as a slash command\n                or a button click\n            view: view definition for the modal dialog\n\n        Returns:\n            Dictionary deserialized from [views.open](https://api.slack.com/methods/views.open) response.\n        \"\"\"\n        return await self._client.web_client.views_open(trigger_id=trigger_id, view=view, **kwargs)\n\n    async def push_modal(self, trigger_id: str, view: dict | View, **kwargs: Any) -&gt; AsyncSlackResponse:\n        \"\"\"Push a new view onto the stack of a modal that was already opened\n\n        Push a new view onto the stack of a modal that was already opened by a open_modal call. At most 3 views can be\n        active in a modal at the same time. For more information on the lifecycle of modals, refer to the\n        [relevant Slack documentation](https://api.slack.com/surfaces/modals)\n\n        Args:\n            trigger_id: trigger id is provided by Slack when a user action is performed, such as a slash command\n                or a button click\n            view: view definition for the modal dialog\n\n        Returns:\n            Dictionary deserialized from [views.push](https://api.slack.com/methods/views.push) response.\n        \"\"\"\n        return await self._client.push_modal(trigger_id=trigger_id, view=view, **kwargs)\n\n    async def update_modal(\n        self,\n        view: dict | View,\n        view_id: str | None = None,\n        external_id: str | None = None,\n        hash: str | None = None,\n        **kwargs: Any,\n    ) -&gt; AsyncSlackResponse:\n        \"\"\"Update a modal dialog\n\n        Update a modal dialog that was previously opened. You can update the view by providing the view_id or the\n        external_id of the modal. external_id has precedence over view_id, but at least one needs to be provided.\n        You can also provide a hash of the view that you want to update to prevent race conditions.\n\n        Args:\n            view: view definition for the modal dialog\n            view_id: id of the view to update\n            external_id: external id of the view to update\n            hash: hash of the view to update\n        Returns:\n            Dictionary deserialized from [views.update](https://api.slack.com/methods/views.update) response.\n        \"\"\"\n        return await self._client.update_modal(view=view, view_id=view_id, external_id=external_id, hash=hash, **kwargs)\n\n    async def publish_home_tab(\n        self, user: User | str, view: dict | View, hash: str | None = None, **kwargs: Any\n    ) -&gt; AsyncSlackResponse:\n        \"\"\"Publish a view to the home tab of a user\n\n        Publish a view to the home tab of a user. The view will be visible to the user when they open the home tab of\n        your Slack app. This method can be used both to publish a new view for the home tab or update an existing view.\n        You can provide a hash of the view that you want to update to prevent race conditions.\n\n        Warning:\n            Be careful with the use of this method, as you might be overwriting the user's home tab that was set by\n            another Slack Machine plugin enabled in your bot.\n\n        Args:\n            user: user for whom to publish or update the home tab\n            view: view definition for the home tab\n            hash: hash of the view to update\n\n        Returns:\n            Dictionary deserialized from [views.publish](https://api.slack.com/methods/views.publish) response.\n        \"\"\"\n        return await self._client.publish_home_tab(user=user, view=view, hash=hash, **kwargs)\n</code></pre>"},{"location":"api/#machine.plugins.base.MachineBasePlugin.users","title":"<code>users: dict[str, User]</code>  <code>property</code>","text":"<p>Dictionary of all users in the Slack workspace</p> <p>Returns:</p> Type Description <code>dict[str, User]</code> <p>a dictionary of all users in the Slack workspace, where the key is the user id and the value is a <code>User</code> object</p>"},{"location":"api/#machine.plugins.base.MachineBasePlugin.users_by_email","title":"<code>users_by_email: dict[str, User]</code>  <code>property</code>","text":"<p>Dictionary of all users in the Slack workspace by email</p> Note <p>not every user might have an email address in their profile, so this dictionary might not contain all users in the Slack workspace</p> <p>Returns:</p> Type Description <code>dict[str, User]</code> <p>a dictionary of all users in the Slack workspace, where the key is the email and the value is a <code>User</code> object</p>"},{"location":"api/#machine.plugins.base.MachineBasePlugin.channels","title":"<code>channels: dict[str, Channel]</code>  <code>property</code>","text":"<p>List of all channels in the Slack workspace</p> <p>This is a list of all channels in the Slack workspace that the bot is aware of. This includes all public channels, all private channels the bot is a member of and all DM channels the bot is a member of.</p> <p>Returns:</p> Type Description <code>dict[str, Channel]</code> <p>a list of all channels in the Slack workspace, where each channel is a <code>Channel</code> object</p>"},{"location":"api/#machine.plugins.base.MachineBasePlugin.web_client","title":"<code>web_client: AsyncWebClient</code>  <code>property</code>","text":"<p>Slack SDK web client to access the Slack Web API</p> <p>Returns:</p> Type Description <code>AsyncWebClient</code> <p>an instance of <code>AsyncWebClient</code></p>"},{"location":"api/#machine.plugins.base.MachineBasePlugin.bot_info","title":"<code>bot_info: dict[str, Any]</code>  <code>property</code>","text":"<p>Information about the bot user in Slack</p> <p>This will return a dictionary with information about the bot user in Slack that represents Slack Machine</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Bot user</p>"},{"location":"api/#machine.plugins.base.MachineBasePlugin.init","title":"<code>init() -&gt; None</code>  <code>async</code>","text":"<p>Initialize plugin</p> <p>This method can be implemented by concrete plugin classes. It will be called once for each plugin, when that plugin is first loaded. You can refer to settings via <code>self.settings</code>, and access storage through <code>self.storage</code>, but the Slack client has not been initialized yet, so you cannot send or process messages during initialization.</p> Source code in <code>src/machine/plugins/base.py</code> <pre><code>async def init(self) -&gt; None:\n    \"\"\"Initialize plugin\n\n    This method can be implemented by concrete plugin classes. It will be called **once**\n    for each plugin, when that plugin is first loaded. You can refer to settings via\n    `self.settings`, and access storage through `self.storage`, but the Slack client has\n    not been initialized yet, so you cannot send or process messages during initialization.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"api/#machine.plugins.base.MachineBasePlugin.find_channel_by_name","title":"<code>find_channel_by_name(channel_name: str) -&gt; Channel | None</code>","text":"<p>Find a channel by its name, irrespective of a preceding pound symbol. This does not include DMs.</p> <p>Parameters:</p> Name Type Description Default <code>channel_name</code> <code>str</code> <p>The name of the channel to retrieve.</p> required <p>Returns:</p> Type Description <code>Channel | None</code> <p>The channel if found, <code>None</code> otherwise.</p> Source code in <code>src/machine/plugins/base.py</code> <pre><code>def find_channel_by_name(self, channel_name: str) -&gt; Channel | None:\n    \"\"\"Find a channel by its name, irrespective of a preceding pound symbol. This does not include DMs.\n\n    Args:\n        channel_name: The name of the channel to retrieve.\n\n    Returns:\n        The channel if found, `None` otherwise.\n    \"\"\"\n    if channel_name.startswith(\"#\"):\n        channel_name = channel_name[1:]\n    for c in self.channels.values():\n        if c.name_normalized and channel_name.lower() == c.name_normalized.lower():\n            return c\n    return None\n</code></pre>"},{"location":"api/#machine.plugins.base.MachineBasePlugin.get_user_by_id","title":"<code>get_user_by_id(user_id: str) -&gt; User | None</code>","text":"<p>Get a user by their ID.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>The ID of the user to retrieve.</p> required <p>Returns:</p> Type Description <code>User | None</code> <p>The user if found, None otherwise.</p> Source code in <code>src/machine/plugins/base.py</code> <pre><code>def get_user_by_id(self, user_id: str) -&gt; User | None:\n    \"\"\"Get a user by their ID.\n\n    Args:\n        user_id: The ID of the user to retrieve.\n\n    Returns:\n        The user if found, None otherwise.\n    \"\"\"\n    return self.users.get(user_id)\n</code></pre>"},{"location":"api/#machine.plugins.base.MachineBasePlugin.get_user_by_email","title":"<code>get_user_by_email(email: str) -&gt; User | None</code>","text":"<p>Get a user by their email address.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>The email address of the user to retrieve.</p> required <p>Returns:</p> Type Description <code>User | None</code> <p>The user if found, None otherwise.</p> Source code in <code>src/machine/plugins/base.py</code> <pre><code>def get_user_by_email(self, email: str) -&gt; User | None:\n    \"\"\"Get a user by their email address.\n\n    Args:\n        email: The email address of the user to retrieve.\n\n    Returns:\n        The user if found, None otherwise.\n    \"\"\"\n    return self._client.get_user_by_email(email)\n</code></pre>"},{"location":"api/#machine.plugins.base.MachineBasePlugin.at","title":"<code>at(user: User) -&gt; str</code>","text":"<p>Create a mention of the provided user</p> <p>Create a mention of the provided user in the form of <code>&lt;@[user_id]&gt;</code>. This method is convenient when you want to include mentions in your message. This method does not send a message, but should be used together with methods like <code>say()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>User</code> <p>user your want to mention</p> required <p>Returns:</p> Type Description <code>str</code> <p>user mention</p> Source code in <code>src/machine/plugins/base.py</code> <pre><code>def at(self, user: User) -&gt; str:\n    \"\"\"Create a mention of the provided user\n\n    Create a mention of the provided user in the form of `&lt;@[user_id]&gt;`. This method is\n    convenient when you want to include mentions in your message. This method does not send\n    a message, but should be used together with methods like\n    [`say()`][machine.plugins.base.MachineBasePlugin.say].\n\n    Args:\n        user: user your want to mention\n\n    Returns:\n        user mention\n    \"\"\"\n    return user.fmt_mention()\n</code></pre>"},{"location":"api/#machine.plugins.base.MachineBasePlugin.say","title":"<code>say(channel: Channel | str, text: str | None = None, attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None, blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None, thread_ts: str | None = None, ephemeral_user: User | str | None = None, **kwargs: Any) -&gt; AsyncSlackResponse</code>  <code>async</code>","text":"<p>Send a message to a channel</p> <p>Send a message to a channel using the WebAPI. Allows for rich formatting using blocks and/or attachments. You can provide blocks and attachments as Python dicts or you can use the convenience classes that the underlying slack client provides. Can also reply in-thread and send ephemeral messages, visible to only one user. Ephemeral messages and threaded messages are mutually exclusive, and <code>ephemeral_user</code> takes precedence over <code>thread_ts</code></p> <p>Any extra kwargs you provide, will be passed on directly to the chat.postMessage or chat.postEphemeral request.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Channel | str</code> <p><code>Channel</code> object or id of channel to send message to. Can be public or private (group) channel, or DM channel.</p> required <code>text</code> <code>str | None</code> <p>message text</p> <code>None</code> <code>attachments</code> <code>Sequence[Attachment] | Sequence[dict[str, Any]] | None</code> <p>optional attachments (see attachments</p> <code>None</code> <code>blocks</code> <code>Sequence[Block] | Sequence[dict[str, Any]] | None</code> <p>optional blocks (see blocks)</p> <code>None</code> <code>thread_ts</code> <code>str | None</code> <p>optional timestamp of thread, to send a message in that thread</p> <code>None</code> <code>ephemeral_user</code> <code>User | str | None</code> <p>optional user name or id if the message needs to visible to a specific user only</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncSlackResponse</code> <p>Dictionary deserialized from chat.postMessage response, or chat.postEphemeral if <code>ephemeral_user</code> is set.</p> Source code in <code>src/machine/plugins/base.py</code> <pre><code>async def say(\n    self,\n    channel: Channel | str,\n    text: str | None = None,\n    attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None,\n    blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None,\n    thread_ts: str | None = None,\n    ephemeral_user: User | str | None = None,\n    **kwargs: Any,\n) -&gt; AsyncSlackResponse:\n    \"\"\"Send a message to a channel\n\n    Send a message to a channel using the WebAPI. Allows for rich formatting using\n    [blocks] and/or [attachments]. You can provide blocks and attachments as Python dicts or\n    you can use the [convenience classes] that the underlying slack client provides.\n    Can also reply in-thread and send ephemeral messages, visible to only one user.\n    Ephemeral messages and threaded messages are mutually exclusive, and `ephemeral_user`\n    takes precedence over `thread_ts`\n\n    Any extra kwargs you provide, will be passed on directly to the [chat.postMessage] or\n    [chat.postEphemeral] request.\n\n    [attachments]: https://api.slack.com/docs/message-attachments\n    [blocks]: https://api.slack.com/reference/block-kit/blocks\n    [convenience classes]:\n        https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes\n    [chat.postMessage]: https://api.slack.com/methods/chat.postMessage\n    [chat.postEphemeral]: https://api.slack.com/methods/chat.postEphemeral\n\n    Args:\n        channel: [`Channel`][machine.models.channel.Channel] object or id of channel to send\n            message to. Can be public or private (group) channel, or DM channel.\n        text: message text\n        attachments: optional attachments (see [attachments](https://api.slack.com/docs/message-attachments)\n        blocks: optional blocks (see [blocks](https://api.slack.com/reference/block-kit/blocks))\n        thread_ts: optional timestamp of thread, to send a message in that thread\n        ephemeral_user: optional user name or id if the message needs to visible\n            to a specific user only\n\n    Returns:\n        Dictionary deserialized from [chat.postMessage](https://api.slack.com/methods/chat.postMessage) response,\n            or [chat.postEphemeral](https://api.slack.com/methods/chat.postEphemeral) if `ephemeral_user` is set.\n    \"\"\"\n    return await self._client.send(\n        channel,\n        text=text,\n        attachments=attachments,\n        blocks=blocks,\n        thread_ts=thread_ts,\n        ephemeral_user=ephemeral_user,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/#machine.plugins.base.MachineBasePlugin.say_scheduled","title":"<code>say_scheduled(when: datetime, channel: Channel | str, text: str, attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None, blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None, thread_ts: str | None = None, **kwargs: Any) -&gt; AsyncSlackResponse</code>  <code>async</code>","text":"<p>Schedule a message to a channel</p> <p>This is the scheduled version of <code>say()</code>. It behaves the same, but will send the message at the scheduled time.</p> <p>Parameters:</p> Name Type Description Default <code>when</code> <code>datetime</code> <p>when you want the message to be sent, as <code>datetime</code> instance</p> required <code>channel</code> <code>Channel | str</code> <p><code>Channel</code> object or id of channel to send message to. Can be public or private (group) channel, or DM channel.</p> required <code>text</code> <code>str</code> <p>message text</p> required <code>attachments</code> <code>Sequence[Attachment] | Sequence[dict[str, Any]] | None</code> <p>optional attachments (see attachments)</p> <code>None</code> <code>blocks</code> <code>Sequence[Block] | Sequence[dict[str, Any]] | None</code> <p>optional blocks (see blocks)</p> <code>None</code> <code>thread_ts</code> <code>str | None</code> <p>optional timestamp of thread, to send a message in that thread</p> <code>None</code> <p>Returns:     Dictionary deserialized from chat.scheduleMessage         response.</p> Source code in <code>src/machine/plugins/base.py</code> <pre><code>async def say_scheduled(\n    self,\n    when: datetime,\n    channel: Channel | str,\n    text: str,\n    attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None,\n    blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None,\n    thread_ts: str | None = None,\n    **kwargs: Any,\n) -&gt; AsyncSlackResponse:\n    \"\"\"Schedule a message to a channel\n\n    This is the scheduled version of [`say()`][machine.plugins.base.MachineBasePlugin.say].\n    It behaves the same, but will send the message at the scheduled time.\n\n    Args:\n        when: when you want the message to be sent, as [`datetime`][datetime.datetime] instance\n        channel: [`Channel`][machine.models.channel.Channel] object or id of channel to send\n            message to. Can be public or private (group) channel, or DM channel.\n        text: message text\n        attachments: optional attachments (see [attachments](https://api.slack.com/docs/message-attachments))\n        blocks: optional blocks (see [blocks](https://api.slack.com/reference/block-kit/blocks))\n        thread_ts: optional timestamp of thread, to send a message in that thread\n    Returns:\n        Dictionary deserialized from [chat.scheduleMessage](https://api.slack.com/methods/chat.scheduleMessage)\n            response.\n    \"\"\"\n    return await self._client.send_scheduled(\n        when,\n        channel,\n        text=text,\n        attachments=attachments,\n        blocks=blocks,\n        thread_ts=thread_ts,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/#machine.plugins.base.MachineBasePlugin.update","title":"<code>update(channel: Channel | str, ts: str, text: str | None = None, attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None, blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None, ephemeral_user: User | str | None = None, **kwargs: Any) -&gt; AsyncSlackResponse</code>  <code>async</code>","text":"<p>Update an existing message</p> <p>Update an existing message using the WebAPI. Allows for rich formatting using blocks and/or attachments. You can provide blocks and attachments as Python dicts or you can use the convenience classes that the underlying slack client provides. Can also update in-thread and ephemeral messages, visible to only one user. Any extra kwargs you provide, will be passed on directly to the <code>chat.update</code> request.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Channel | str</code> <p><code>Channel</code> object or id of channel to send message to. Can be public or private (group) channel, or DM channel.</p> required <code>ts</code> <code>str</code> <p>timestamp of the message to be updated.</p> required <code>text</code> <code>str | None</code> <p>message text</p> <code>None</code> <code>attachments</code> <code>Sequence[Attachment] | Sequence[dict[str, Any]] | None</code> <p>optional attachments (see attachments)</p> <code>None</code> <code>blocks</code> <code>Sequence[Block] | Sequence[dict[str, Any]] | None</code> <p>optional blocks (see blocks)</p> <code>None</code> <code>ephemeral_user</code> <code>User | str | None</code> <p>optional user name or id if the message needs to visible to a specific user only</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncSlackResponse</code> <p>Dictionary deserialized from <code>chat.update</code> response</p> Source code in <code>src/machine/plugins/base.py</code> <pre><code>async def update(\n    self,\n    channel: Channel | str,\n    ts: str,\n    text: str | None = None,\n    attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None,\n    blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None,\n    ephemeral_user: User | str | None = None,\n    **kwargs: Any,\n) -&gt; AsyncSlackResponse:\n    \"\"\"Update an existing message\n\n    Update an existing message using the WebAPI. Allows for rich formatting using\n    [blocks] and/or [attachments]. You can provide blocks and attachments as Python dicts or\n    you can use the [convenience classes] that the underlying slack client provides.\n    Can also update in-thread and ephemeral messages, visible to only one user.\n    Any extra kwargs you provide, will be passed on directly to the [`chat.update`][chat_update] request.\n\n    [attachments]: https://api.slack.com/docs/message-attachments\n    [blocks]: https://api.slack.com/reference/block-kit/blocks\n    [convenience classes]: https://github.com/slackapi/python-slack-sdk/tree/main/slack/web/classes\n    [chat_update]: https://api.slack.com/methods/chat.update\n\n    Args:\n        channel: [`Channel`][machine.models.channel.Channel] object or id of channel to send\n            message to. Can be public or private (group) channel, or DM channel.\n        ts: timestamp of the message to be updated.\n        text: message text\n        attachments: optional attachments (see [attachments](https://api.slack.com/docs/message-attachments))\n        blocks: optional blocks (see [blocks](https://api.slack.com/reference/block-kit/blocks))\n        ephemeral_user: optional user name or id if the message needs to visible\n            to a specific user only\n\n    Returns:\n        Dictionary deserialized from [`chat.update`](https://api.slack.com/methods/chat.update) response\n    \"\"\"\n    return await self._client.update(\n        channel,\n        ts=ts,\n        text=text,\n        attachments=attachments,\n        blocks=blocks,\n        ephemeral_user=ephemeral_user,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/#machine.plugins.base.MachineBasePlugin.delete","title":"<code>delete(channel: Channel | str, ts: str, **kwargs: Any) -&gt; AsyncSlackResponse</code>  <code>async</code>","text":"<p>Delete an existing message</p> <p>Delete an existing message using the WebAPI. Any extra kwargs you provide, will be passed on directly to the <code>chat.delete</code> request.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Channel | str</code> <p><code>Channel</code> object or id of channel to send message to. Can be public or private (group) channel, or DM channel.</p> required <code>ts</code> <code>str</code> <p>timestamp of the message to be deleted.</p> required <p>Returns:</p> Type Description <code>AsyncSlackResponse</code> <p>Dictionary deserialized from <code>chat.delete</code> response</p> Source code in <code>src/machine/plugins/base.py</code> <pre><code>async def delete(\n    self,\n    channel: Channel | str,\n    ts: str,\n    **kwargs: Any,\n) -&gt; AsyncSlackResponse:\n    \"\"\"Delete an existing message\n\n    Delete an existing message using the WebAPI.\n    Any extra kwargs you provide, will be passed on directly to the [`chat.delete`][chat_delete] request.\n\n    [chat_delete]: https://api.slack.com/methods/chat.delete\n\n    Args:\n        channel: [`Channel`][machine.models.channel.Channel] object or id of channel to send\n            message to. Can be public or private (group) channel, or DM channel.\n        ts: timestamp of the message to be deleted.\n\n    Returns:\n        Dictionary deserialized from [`chat.delete`](https://api.slack.com/methods/chat.delete) response\n    \"\"\"\n    return await self._client.delete(\n        channel,\n        ts=ts,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/#machine.plugins.base.MachineBasePlugin.react","title":"<code>react(channel: Channel | str, ts: str, emoji: str) -&gt; AsyncSlackResponse</code>  <code>async</code>","text":"<p>React to a message in a channel</p> <p>Add a reaction to a message in a channel. What message to react to, is determined by the combination of the channel and the timestamp of the message.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Channel | str</code> <p><code>Channel</code> object or id of channel to send message to. Can be public or private (group) channel, or DM channel.</p> required <code>ts</code> <code>str</code> <p>timestamp of the message to react to</p> required <code>emoji</code> <code>str</code> <p>what emoji to react with (should be a string, like 'angel', 'thumbsup', etc.)</p> required <p>Returns:</p> Type Description <code>AsyncSlackResponse</code> <p>Dictionary deserialized from reactions.add response.</p> Source code in <code>src/machine/plugins/base.py</code> <pre><code>async def react(self, channel: Channel | str, ts: str, emoji: str) -&gt; AsyncSlackResponse:\n    \"\"\"React to a message in a channel\n\n    Add a reaction to a message in a channel. What message to react to, is determined by the\n    combination of the channel and the timestamp of the message.\n\n    Args:\n        channel: [`Channel`][machine.models.channel.Channel] object or id of channel to send\n            message to. Can be public or private (group) channel, or DM channel.\n        ts: timestamp of the message to react to\n        emoji: what emoji to react with (should be a string, like 'angel', 'thumbsup', etc.)\n\n    Returns:\n        Dictionary deserialized from [reactions.add](https://api.slack.com/methods/reactions.add) response.\n    \"\"\"\n    return await self._client.react(channel, ts, emoji)\n</code></pre>"},{"location":"api/#machine.plugins.base.MachineBasePlugin.send_dm","title":"<code>send_dm(user: User | str, text: str | None = None, attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None, blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None, **kwargs: Any) -&gt; AsyncSlackResponse</code>  <code>async</code>","text":"<p>Send a Direct Message</p> <p>Send a Direct Message to a user by opening a DM channel and sending a message to it. Allows for rich formatting using blocks and/or attachments. You can provide blocks and attachments as Python dicts or you can use the convenience classes that the underlying slack client provides. Any extra kwargs you provide, will be passed on directly to the chat.postMessage request.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>User | str</code> <p><code>User</code> object or id of user to send DM to.</p> required <code>text</code> <code>str | None</code> <p>message text</p> <code>None</code> <code>attachments</code> <code>Sequence[Attachment] | Sequence[dict[str, Any]] | None</code> <p>optional attachments (see attachments)</p> <code>None</code> <code>blocks</code> <code>Sequence[Block] | Sequence[dict[str, Any]] | None</code> <p>optional blocks (see blocks)</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncSlackResponse</code> <p>Dictionary deserialized from chat.postMessage response.</p> Source code in <code>src/machine/plugins/base.py</code> <pre><code>async def send_dm(\n    self,\n    user: User | str,\n    text: str | None = None,\n    attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None,\n    blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None,\n    **kwargs: Any,\n) -&gt; AsyncSlackResponse:\n    \"\"\"Send a Direct Message\n\n    Send a Direct Message to a user by opening a DM channel and sending a message to it. Allows\n    for rich formatting using [blocks] and/or [attachments]. You can provide blocks and\n    attachments as Python dicts or you can use the [convenience classes] that the underlying\n    slack client provides.\n    Any extra kwargs you provide, will be passed on directly to the [chat.postMessage] request.\n\n    [attachments]: https://api.slack.com/docs/message-attachments\n    [blocks]: https://api.slack.com/reference/block-kit/blocks\n    [convenience classes]:\n        https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes\n    [chat.postMessage]: https://api.slack.com/methods/chat.postMessage\n\n    Args:\n        user: [`User`][machine.models.user.User] object or id of user to send DM to.\n        text: message text\n        attachments: optional attachments (see [attachments](https://api.slack.com/docs/message-attachments))\n        blocks: optional blocks (see [blocks](https://api.slack.com/reference/block-kit/blocks))\n\n    Returns:\n        Dictionary deserialized from [chat.postMessage](https://api.slack.com/methods/chat.postMessage) response.\n    \"\"\"\n    return await self._client.send_dm(user, text, attachments=attachments, blocks=blocks, **kwargs)\n</code></pre>"},{"location":"api/#machine.plugins.base.MachineBasePlugin.send_dm_scheduled","title":"<code>send_dm_scheduled(when: datetime, user: User | str, text: str, attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None, blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None, **kwargs: Any) -&gt; AsyncSlackResponse</code>  <code>async</code>","text":"<p>Schedule a Direct Message</p> <p>This is the scheduled version of <code>send_dm()</code>. It behaves the same, but will send the DM at the scheduled time.</p> <p>Parameters:</p> Name Type Description Default <code>when</code> <code>datetime</code> <p>when you want the message to be sent, as <code>datetime</code> instance</p> required <code>user</code> <code>User | str</code> <p><code>User</code> object or id of user to send DM to.</p> required <code>text</code> <code>str</code> <p>message text</p> required <code>attachments</code> <code>Sequence[Attachment] | Sequence[dict[str, Any]] | None</code> <p>optional attachments (see attachments)</p> <code>None</code> <code>blocks</code> <code>Sequence[Block] | Sequence[dict[str, Any]] | None</code> <p>optional blocks (see blocks)</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncSlackResponse</code> <p>Dictionary deserialized from chat.scheduleMessage response.</p> Source code in <code>src/machine/plugins/base.py</code> <pre><code>async def send_dm_scheduled(\n    self,\n    when: datetime,\n    user: User | str,\n    text: str,\n    attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None,\n    blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None,\n    **kwargs: Any,\n) -&gt; AsyncSlackResponse:\n    \"\"\"Schedule a Direct Message\n\n    This is the scheduled version of\n    [`send_dm()`][machine.plugins.base.MachineBasePlugin.send_dm]. It behaves the same, but\n    will send the DM at the scheduled time.\n\n    Args:\n        when: when you want the message to be sent, as [`datetime`][datetime.datetime] instance\n        user: [`User`][machine.models.user.User] object or id of user to send DM to.\n        text: message text\n        attachments: optional attachments (see [attachments](https://api.slack.com/docs/message-attachments))\n        blocks: optional blocks (see [blocks](https://api.slack.com/reference/block-kit/blocks))\n\n    Returns:\n        Dictionary deserialized from [chat.scheduleMessage](https://api.slack.com/methods/chat.scheduleMessage)\n            response.\n    \"\"\"\n    return await self._client.send_dm_scheduled(\n        when, user, text=text, attachments=attachments, blocks=blocks, **kwargs\n    )\n</code></pre>"},{"location":"api/#machine.plugins.base.MachineBasePlugin.open_im","title":"<code>open_im(users: User | str | list[User | str]) -&gt; str</code>  <code>async</code>","text":"<p>Open a DM channel with one or more users</p> <p>Open a DM channel with one or more users. If the DM channel already exists, the existing channel id will be returned. If the DM channel does not exist, a new channel will be created and the id of the new channel will be returned.</p> <p>Parameters:</p> Name Type Description Default <code>users</code> <code>User | str | list[User | str]</code> <p><code>User</code> object or id of user to open DM with, or a list of user objects or user ids.</p> required <p>Returns:</p> Type Description <code>str</code> <p>id of the DM channel</p> Source code in <code>src/machine/plugins/base.py</code> <pre><code>async def open_im(self, users: User | str | list[User | str]) -&gt; str:\n    \"\"\"Open a DM channel with one or more users\n\n    Open a DM channel with one or more users. If the DM channel already exists, the existing channel id\n    will be returned. If the DM channel does not exist, a new channel will be created and the\n    id of the new channel will be returned.\n\n    Args:\n        users: [`User`][machine.models.user.User] object or id of user to open DM with, or a list of user objects\n            or user ids.\n\n    Returns:\n        id of the DM channel\n    \"\"\"\n    return await self._client.open_im(users)\n</code></pre>"},{"location":"api/#machine.plugins.base.MachineBasePlugin.emit","title":"<code>emit(event: str, **kwargs: Any) -&gt; None</code>","text":"<p>Emit an event</p> <p>Emit an event that plugins can listen for. You can include arbitrary data as keyword arguments.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>str</code> <p>name of the event</p> required <code>**kwargs</code> <code>Any</code> <p>any data you want to emit with the event</p> <code>{}</code> Source code in <code>src/machine/plugins/base.py</code> <pre><code>def emit(self, event: str, **kwargs: Any) -&gt; None:\n    \"\"\"Emit an event\n\n    Emit an event that plugins can listen for. You can include arbitrary data as keyword\n    arguments.\n\n    Args:\n        event: name of the event\n        **kwargs: any data you want to emit with the event\n    \"\"\"\n    ee.emit(event, self, **kwargs)\n</code></pre>"},{"location":"api/#machine.plugins.base.MachineBasePlugin.pin_message","title":"<code>pin_message(channel: Channel | str, ts: str) -&gt; AsyncSlackResponse</code>  <code>async</code>","text":"<p>Pin message</p> <p>Pin a message in a channel</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Channel | str</code> <p>channel to pin the message in</p> required <code>ts</code> <code>str</code> <p>timestamp of the message to pin</p> required <p>Returns:</p> Type Description <code>AsyncSlackResponse</code> <p>Dictionary deserialized from pins.add response.</p> Source code in <code>src/machine/plugins/base.py</code> <pre><code>async def pin_message(self, channel: Channel | str, ts: str) -&gt; AsyncSlackResponse:\n    \"\"\"Pin message\n\n    Pin a message in a channel\n\n    Args:\n        channel: channel to pin the message in\n        ts: timestamp of the message to pin\n\n    Returns:\n        Dictionary deserialized from [pins.add](https://api.slack.com/methods/pins.add) response.\n    \"\"\"\n    return await self._client.pin_message(channel, ts)\n</code></pre>"},{"location":"api/#machine.plugins.base.MachineBasePlugin.unpin_message","title":"<code>unpin_message(channel: Channel | str, ts: str) -&gt; AsyncSlackResponse</code>  <code>async</code>","text":"<p>Unpin message</p> <p>Unpin a message that was previously pinned in a channel</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Channel | str</code> <p>channel where the message is pinned that needs to be unpinned</p> required <code>ts</code> <code>str</code> <p>timestamp of the message to unpin</p> required <p>Returns:</p> Type Description <code>AsyncSlackResponse</code> <p>Dictionary deserialized from pins.remove response.</p> Source code in <code>src/machine/plugins/base.py</code> <pre><code>async def unpin_message(self, channel: Channel | str, ts: str) -&gt; AsyncSlackResponse:\n    \"\"\"Unpin message\n\n    Unpin a message that was previously pinned in a channel\n\n    Args:\n        channel: channel where the message is pinned that needs to be unpinned\n        ts: timestamp of the message to unpin\n\n    Returns:\n        Dictionary deserialized from [pins.remove](https://api.slack.com/methods/pins.remove) response.\n    \"\"\"\n    return await self._client.unpin_message(channel, ts)\n</code></pre>"},{"location":"api/#machine.plugins.base.MachineBasePlugin.set_topic","title":"<code>set_topic(channel: Channel | str, topic: str, **kwargs: Any) -&gt; AsyncSlackResponse</code>  <code>async</code>","text":"<p>Set channel topic</p> <p>Set or update topic for the channel</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Channel | str</code> <p>channel where topic needs to be set or updated</p> required <code>topic</code> <code>str</code> <p>topic for the channel (slack does not support formatting for topics)</p> required <p>Returns:</p> Type Description <code>AsyncSlackResponse</code> <p>Dictionary deserialized from conversations.setTopic response.</p> Source code in <code>src/machine/plugins/base.py</code> <pre><code>async def set_topic(self, channel: Channel | str, topic: str, **kwargs: Any) -&gt; AsyncSlackResponse:\n    \"\"\"Set channel topic\n\n    Set or update topic for the channel\n\n    Args:\n        channel: channel where topic needs to be set or updated\n        topic: topic for the channel (slack does not support formatting for topics)\n\n    Returns:\n        Dictionary deserialized from [conversations.setTopic](https://api.slack.com/methods/conversations.setTopic)\n            response.\n    \"\"\"\n    return await self._client.set_topic(channel, topic, **kwargs)\n</code></pre>"},{"location":"api/#machine.plugins.base.MachineBasePlugin.open_modal","title":"<code>open_modal(trigger_id: str, view: dict | View, **kwargs: Any) -&gt; AsyncSlackResponse</code>  <code>async</code>","text":"<p>Open a modal dialog</p> <p>Open a modal dialog in response to a user action. The modal dialog can be used to collect information from the user, or to display information to the user.</p> <p>Parameters:</p> Name Type Description Default <code>trigger_id</code> <code>str</code> <p>trigger id is provided by Slack when a user action is performed, such as a slash command or a button click</p> required <code>view</code> <code>dict | View</code> <p>view definition for the modal dialog</p> required <p>Returns:</p> Type Description <code>AsyncSlackResponse</code> <p>Dictionary deserialized from views.open response.</p> Source code in <code>src/machine/plugins/base.py</code> <pre><code>async def open_modal(self, trigger_id: str, view: dict | View, **kwargs: Any) -&gt; AsyncSlackResponse:\n    \"\"\"Open a modal dialog\n\n    Open a modal dialog in response to a user action. The modal dialog can be used to collect\n    information from the user, or to display information to the user.\n\n    Args:\n        trigger_id: trigger id is provided by Slack when a user action is performed, such as a slash command\n            or a button click\n        view: view definition for the modal dialog\n\n    Returns:\n        Dictionary deserialized from [views.open](https://api.slack.com/methods/views.open) response.\n    \"\"\"\n    return await self._client.web_client.views_open(trigger_id=trigger_id, view=view, **kwargs)\n</code></pre>"},{"location":"api/#machine.plugins.base.MachineBasePlugin.push_modal","title":"<code>push_modal(trigger_id: str, view: dict | View, **kwargs: Any) -&gt; AsyncSlackResponse</code>  <code>async</code>","text":"<p>Push a new view onto the stack of a modal that was already opened</p> <p>Push a new view onto the stack of a modal that was already opened by a open_modal call. At most 3 views can be active in a modal at the same time. For more information on the lifecycle of modals, refer to the relevant Slack documentation</p> <p>Parameters:</p> Name Type Description Default <code>trigger_id</code> <code>str</code> <p>trigger id is provided by Slack when a user action is performed, such as a slash command or a button click</p> required <code>view</code> <code>dict | View</code> <p>view definition for the modal dialog</p> required <p>Returns:</p> Type Description <code>AsyncSlackResponse</code> <p>Dictionary deserialized from views.push response.</p> Source code in <code>src/machine/plugins/base.py</code> <pre><code>async def push_modal(self, trigger_id: str, view: dict | View, **kwargs: Any) -&gt; AsyncSlackResponse:\n    \"\"\"Push a new view onto the stack of a modal that was already opened\n\n    Push a new view onto the stack of a modal that was already opened by a open_modal call. At most 3 views can be\n    active in a modal at the same time. For more information on the lifecycle of modals, refer to the\n    [relevant Slack documentation](https://api.slack.com/surfaces/modals)\n\n    Args:\n        trigger_id: trigger id is provided by Slack when a user action is performed, such as a slash command\n            or a button click\n        view: view definition for the modal dialog\n\n    Returns:\n        Dictionary deserialized from [views.push](https://api.slack.com/methods/views.push) response.\n    \"\"\"\n    return await self._client.push_modal(trigger_id=trigger_id, view=view, **kwargs)\n</code></pre>"},{"location":"api/#machine.plugins.base.MachineBasePlugin.update_modal","title":"<code>update_modal(view: dict | View, view_id: str | None = None, external_id: str | None = None, hash: str | None = None, **kwargs: Any) -&gt; AsyncSlackResponse</code>  <code>async</code>","text":"<p>Update a modal dialog</p> <p>Update a modal dialog that was previously opened. You can update the view by providing the view_id or the external_id of the modal. external_id has precedence over view_id, but at least one needs to be provided. You can also provide a hash of the view that you want to update to prevent race conditions.</p> <p>Parameters:</p> Name Type Description Default <code>view</code> <code>dict | View</code> <p>view definition for the modal dialog</p> required <code>view_id</code> <code>str | None</code> <p>id of the view to update</p> <code>None</code> <code>external_id</code> <code>str | None</code> <p>external id of the view to update</p> <code>None</code> <code>hash</code> <code>str | None</code> <p>hash of the view to update</p> <code>None</code> <p>Returns:     Dictionary deserialized from views.update response.</p> Source code in <code>src/machine/plugins/base.py</code> <pre><code>async def update_modal(\n    self,\n    view: dict | View,\n    view_id: str | None = None,\n    external_id: str | None = None,\n    hash: str | None = None,\n    **kwargs: Any,\n) -&gt; AsyncSlackResponse:\n    \"\"\"Update a modal dialog\n\n    Update a modal dialog that was previously opened. You can update the view by providing the view_id or the\n    external_id of the modal. external_id has precedence over view_id, but at least one needs to be provided.\n    You can also provide a hash of the view that you want to update to prevent race conditions.\n\n    Args:\n        view: view definition for the modal dialog\n        view_id: id of the view to update\n        external_id: external id of the view to update\n        hash: hash of the view to update\n    Returns:\n        Dictionary deserialized from [views.update](https://api.slack.com/methods/views.update) response.\n    \"\"\"\n    return await self._client.update_modal(view=view, view_id=view_id, external_id=external_id, hash=hash, **kwargs)\n</code></pre>"},{"location":"api/#machine.plugins.base.MachineBasePlugin.publish_home_tab","title":"<code>publish_home_tab(user: User | str, view: dict | View, hash: str | None = None, **kwargs: Any) -&gt; AsyncSlackResponse</code>  <code>async</code>","text":"<p>Publish a view to the home tab of a user</p> <p>Publish a view to the home tab of a user. The view will be visible to the user when they open the home tab of your Slack app. This method can be used both to publish a new view for the home tab or update an existing view. You can provide a hash of the view that you want to update to prevent race conditions.</p> Warning <p>Be careful with the use of this method, as you might be overwriting the user's home tab that was set by another Slack Machine plugin enabled in your bot.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>User | str</code> <p>user for whom to publish or update the home tab</p> required <code>view</code> <code>dict | View</code> <p>view definition for the home tab</p> required <code>hash</code> <code>str | None</code> <p>hash of the view to update</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncSlackResponse</code> <p>Dictionary deserialized from views.publish response.</p> Source code in <code>src/machine/plugins/base.py</code> <pre><code>async def publish_home_tab(\n    self, user: User | str, view: dict | View, hash: str | None = None, **kwargs: Any\n) -&gt; AsyncSlackResponse:\n    \"\"\"Publish a view to the home tab of a user\n\n    Publish a view to the home tab of a user. The view will be visible to the user when they open the home tab of\n    your Slack app. This method can be used both to publish a new view for the home tab or update an existing view.\n    You can provide a hash of the view that you want to update to prevent race conditions.\n\n    Warning:\n        Be careful with the use of this method, as you might be overwriting the user's home tab that was set by\n        another Slack Machine plugin enabled in your bot.\n\n    Args:\n        user: user for whom to publish or update the home tab\n        view: view definition for the home tab\n        hash: hash of the view to update\n\n    Returns:\n        Dictionary deserialized from [views.publish](https://api.slack.com/methods/views.publish) response.\n    \"\"\"\n    return await self._client.publish_home_tab(user=user, view=view, hash=hash, **kwargs)\n</code></pre>"},{"location":"api/#machine.plugins.message.Message","title":"<code>machine.plugins.message.Message</code>","text":"<p>A message that was received by the bot</p> <p>This class represents a message that was received by the bot and passed to one or more plugins. It contains the message (text) itself, and metadata about the message, such as the sender of the message, the channel the message was sent to.</p> <p>The <code>Message</code> class also contains convenience methods for replying to the message in the right channel, replying to the sender, etc.</p> Source code in <code>src/machine/plugins/message.py</code> <pre><code>class Message:\n    \"\"\"A message that was received by the bot\n\n    This class represents a message that was received by the bot and passed to one or more\n    plugins. It contains the message (text) itself, and metadata about the message, such as the\n    sender of the message, the channel the message was sent to.\n\n    The `Message` class also contains convenience methods for replying to the message in the\n    right channel, replying to the sender, etc.\n    \"\"\"\n\n    # TODO: create proper class for msg_event\n    def __init__(self, client: SlackClient, msg_event: dict[str, Any]):\n        self._client = client\n        self._msg_event = msg_event\n\n    @property\n    def sender(self) -&gt; User:\n        \"\"\"The sender of the message\n\n        Returns:\n            the User the message was sent by\n        \"\"\"\n        return self._client.users[self._msg_event[\"user\"]]\n\n    @property\n    def channel(self) -&gt; Channel:\n        \"\"\"The channel the message was sent to\n\n        Returns:\n            the Channel the message was sent to\n        \"\"\"\n        return self._client.channels[self._msg_event[\"channel\"]]\n\n    @property\n    def is_dm(self) -&gt; bool:\n        \"\"\"Is the message a direct message\n\n        Returns:\n            `True` if the message was _not_ sent in a channel or group, `False` otherwise\n        \"\"\"\n        channel_id = self._msg_event[\"channel\"]\n        return not (channel_id.startswith(\"C\") or channel_id.startswith(\"G\"))\n\n    @property\n    def text(self) -&gt; str:\n        \"\"\"The body of the actual message\n\n        Returns:\n            the body (text) of the actual message\n        \"\"\"\n        return self._msg_event[\"text\"]\n\n    @property\n    def at_sender(self) -&gt; str:\n        \"\"\"The sender of the message formatted as mention\n\n        Returns:\n            a string representation of the sender of the message, formatted as\n                [mention](https://api.slack.com/docs/message-formatting#linking_to_channels_and_users),\n                to be used in messages\n        \"\"\"\n        return self.sender.fmt_mention()\n\n    @property\n    def ts(self) -&gt; str:\n        \"\"\"The timestamp of the message\n\n        Returns:\n            the timestamp of the message\n        \"\"\"\n        return self._msg_event[\"ts\"]\n\n    @property\n    def in_thread(self) -&gt; bool:\n        \"\"\"Is message in a thread\n\n        Returns:\n            the message is in a thread\n        \"\"\"\n        return \"thread_ts\" in self._msg_event\n\n    async def say(\n        self,\n        text: str | None = None,\n        attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None,\n        blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None,\n        thread_ts: str | None = None,\n        ephemeral: bool = False,\n        **kwargs: Any,\n    ) -&gt; AsyncSlackResponse:\n        \"\"\"Send a new message to the channel the original message was received in\n\n        Send a new message to the channel the original message was received in, using the WebAPI.\n        Allows for rich formatting using [blocks] and/or [attachments]. You can provide blocks\n        and attachments as Python dicts or you can use the [convenience classes] that the\n        underlying slack client provides.\n        Can also reply to a thread and send an ephemeral message only visible to the sender of the\n        original message. Ephemeral messages and threaded messages are mutually exclusive, and\n        `ephemeral` takes precedence over `thread_ts`\n        Any extra kwargs you provide, will be passed on directly to the [chat.postMessage] or\n        [chat.postEphemeral] request.\n\n        [attachments]: https://api.slack.com/docs/message-attachments\n        [blocks]: https://api.slack.com/reference/block-kit/blocks\n        [convenience classes]:\n            https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes\n        [chat.postMessage]: https://api.slack.com/methods/chat.postMessage\n        [chat.postEphemeral]: https://api.slack.com/methods/chat.postEphemeral\n\n        Args:\n            text: message text\n            attachments: optional attachments (see [attachments](https://api.slack.com/docs/message-attachments))\n            blocks: optional blocks (see [blocks](https://api.slack.com/reference/block-kit/blocks))\n            thread_ts: optional timestamp of thread, to send a message in that thread\n            ephemeral: `True/False` wether to send the message as an ephemeral message, only\n                visible to the sender of the original message\n\n        Returns:\n            Dictionary deserialized from [chat.postMessage](https://api.slack.com/methods/chat.postMessage) response,\n                or [chat.postEphemeral](https://api.slack.com/methods/chat.postEphemeral) if `ephemeral` is True.\n\n\n        \"\"\"\n        ephemeral_user = self.sender.id if ephemeral else None\n\n        return await self._client.send(\n            self.channel.id,\n            text=text,\n            attachments=attachments,\n            blocks=blocks,\n            thread_ts=thread_ts,\n            ephemeral_user=ephemeral_user,\n            **kwargs,\n        )\n\n    async def say_scheduled(\n        self,\n        when: datetime,\n        text: str,\n        attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None,\n        blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None,\n        thread_ts: str | None = None,\n        **kwargs: Any,\n    ) -&gt; AsyncSlackResponse:\n        \"\"\"Schedule a message\n\n        This is the scheduled version of [`say()`][machine.plugins.message.Message.say].\n        It behaves the same, but will send the message at the scheduled time.\n\n        Args:\n            when: when you want the message to be sent, as [`datetime`][datetime.datetime] instance\n            text: message text\n            attachments: optional attachments (see [attachments](https://api.slack.com/docs/message-attachments))\n            blocks: optional blocks (see [blocks](https://api.slack.com/reference/block-kit/blocks))\n            thread_ts: optional timestamp of thread, to send a message in that thread\n\n        Returns:\n            Dictionary deserialized from [chat.scheduleMessage](https://api.slack.com/methods/chat.scheduleMessage)\n                response.\n        \"\"\"\n        return await self._client.send_scheduled(\n            when,\n            self.channel.id,\n            text=text,\n            attachments=attachments,\n            blocks=blocks,\n            thread_ts=thread_ts,\n            **kwargs,\n        )\n\n    async def reply(\n        self,\n        text: str | None = None,\n        attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None,\n        blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None,\n        in_thread: bool = False,\n        ephemeral: bool = False,\n        **kwargs: Any,\n    ) -&gt; AsyncSlackResponse:\n        \"\"\"Reply to the sender of the original message\n\n        Reply to the sender of the original message with a new message, mentioning that user. Rich\n        formatting using [blocks] and/or [attachments] is possible. You can provide blocks\n        and attachments as Python dicts or you can use the [convenience classes] that the\n        underlying slack client provides.\n        Can also reply to a thread and send an ephemeral message only visible to the sender of the\n        original message. In the case of in-thread response, the sender of the original message\n        will not be mentioned. Ephemeral messages and threaded messages are mutually exclusive,\n        and `ephemeral` takes precedence over `in_thread`\n        Any extra kwargs you provide, will be passed on directly to the [chat.postMessage] or\n        [chat.postEphemeral] request.\n\n        [attachments]: https://api.slack.com/docs/message-attachments\n        [blocks]: https://api.slack.com/reference/block-kit/blocks\n        [convenience classes]:\n            https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes\n        [chat.postMessage]: https://api.slack.com/methods/chat.postMessage\n        [chat.postEphemeral]: https://api.slack.com/methods/chat.postEphemeral\n\n        Args:\n            text: message text\n            attachments: optional attachments (see [attachments](https://api.slack.com/docs/message-attachments))\n            blocks: optional blocks (see [blocks](https://api.slack.com/reference/block-kit/blocks)\n            in_thread: `True/False` wether to reply to the original message in-thread\n            ephemeral: `True/False` wether to send the message as an ephemeral message, only\n                visible to the sender of the original message\n\n        Returns:\n            Dictionary deserialized from [chat.postMessage](https://api.slack.com/methods/chat.postMessage) response,\n                or [chat.postEphemeral](https://api.slack.com/methods/chat.postEphemeral) if `ephemeral` is True.\n        \"\"\"\n        if in_thread and not ephemeral:\n            return await self.say(text, attachments=attachments, blocks=blocks, thread_ts=self.ts, **kwargs)\n        else:\n            text = self._create_reply(text)\n            return await self.say(text, attachments=attachments, blocks=blocks, ephemeral=ephemeral, **kwargs)\n\n    async def reply_scheduled(\n        self,\n        when: datetime,\n        text: str,\n        attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None,\n        blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None,\n        in_thread: bool = False,\n        **kwargs: Any,\n    ) -&gt; AsyncSlackResponse:\n        \"\"\"Schedule a reply and send it\n\n        This is the scheduled version of [`reply()`][machine.plugins.message.Message.reply].\n        It behaves the same, but will send the reply at the scheduled time.\n\n        Args:\n            when: when you want the message to be sent, as :py:class:`datetime.datetime` instance\n            text: message text\n            attachments: optional attachments (see [attachments](https://api.slack.com/docs/message-attachments))\n            blocks: optional blocks (see [blocks](https://api.slack.com/reference/block-kit/blocks))\n            in_thread: `True/False` wether to reply to the original message in-thread\n\n        Returns:\n            Dictionary deserialized from [chat.scheduleMessage](https://api.slack.com/methods/chat.scheduleMessage)\n                response.\n        \"\"\"\n        if in_thread:\n            return await self.say_scheduled(\n                when, text, attachments=attachments, blocks=blocks, thread_ts=self.ts, **kwargs\n            )\n        else:\n            text = cast(str, self._create_reply(text))\n            return await self.say_scheduled(when, text, attachments=attachments, blocks=blocks, **kwargs)\n\n    async def reply_dm(\n        self,\n        text: str | None = None,\n        attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None,\n        blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None,\n        **kwargs: Any,\n    ) -&gt; AsyncSlackResponse:\n        \"\"\"Reply to the sender of the original message with a DM\n\n        Reply in a Direct Message to the sender of the original message by opening a DM channel and\n        sending a message to it. Allows for rich formatting using [blocks] and/or [attachments].\n        You can provide blocks and attachments as Python dicts or you can use the\n        [convenience classes] that the underlying slack client provides.\n        Any extra kwargs you provide, will be passed on directly to the [chat.postMessage] request.\n\n        [attachments]: https://api.slack.com/docs/message-attachments\n        [blocks]: https://api.slack.com/reference/block-kit/blocks\n        [convenience classes]:\n            https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes\n        [chat.postMessage]: https://api.slack.com/methods/chat.postMessage\n\n        Args:\n            text: message text\n            attachments: optional attachments (see [attachments](https://api.slack.com/docs/message-attachments))\n            blocks: optional blocks (see [blocks](https://api.slack.com/reference/block-kit/blocks))\n\n        Returns:\n            Dictionary deserialized from [chat.postMessage](https://api.slack.com/methods/chat.postMessage) response.\n        \"\"\"\n        return await self._client.send_dm(self.sender.id, text, attachments=attachments, blocks=blocks, **kwargs)\n\n    async def reply_dm_scheduled(\n        self,\n        when: datetime,\n        text: str,\n        attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None,\n        blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None,\n        **kwargs: Any,\n    ) -&gt; AsyncSlackResponse:\n        \"\"\"Schedule a DM reply and send it\n\n        This is the scheduled version of [`reply_dm()`][machine.plugins.message.Message.reply_dm].\n        It behaves the same, but will send the DM at the scheduled time.\n\n        Args:\n            when: when you want the message to be sent, as :py:class:`datetime.datetime` instance\n            text: message text\n            attachments: optional attachments (see [attachments](https://api.slack.com/docs/message-attachments))\n            blocks: optional blocks (see [blocks](https://api.slack.com/reference/block-kit/blocks))\n\n        Returns:\n            Dictionary deserialized from [chat.scheduleMessage](https://api.slack.com/methods/chat.scheduleMessage)\n                response.\n        \"\"\"\n        return await self._client.send_dm_scheduled(\n            when, self.sender.id, text=text, attachments=attachments, blocks=blocks, **kwargs\n        )\n\n    async def react(self, emoji: str) -&gt; AsyncSlackResponse:\n        \"\"\"React to the original message\n\n        Add a reaction to the original message\n\n        Args:\n            emoji: what emoji to react with (should be a string, like 'angel', 'thumbsup', etc.)\n\n        Returns:\n            Dictionary deserialized from [reactions.add](https://api.slack.com/methods/reactions.add) response.\n        \"\"\"\n        return await self._client.react(self.channel.id, self._msg_event[\"ts\"], emoji)\n\n    def _create_reply(self, text: str | None) -&gt; str | None:\n        if not self.is_dm and text is not None:\n            return f\"{self.at_sender}: {text}\"\n        else:\n            return text\n\n    async def pin_message(self) -&gt; AsyncSlackResponse:\n        \"\"\"Pin message\n\n        Pin the current message in the channel it was posted in\n\n        Returns:\n            Dictionary deserialized from [pins.add](https://api.slack.com/methods/pins.add) response.\n        \"\"\"\n        return await self._client.pin_message(self.channel, self.ts)\n\n    def __str__(self) -&gt; str:\n        if self.channel.is_im:\n            message = f\"Message '{self.text}', sent by user @{self.sender.profile.real_name} in DM\"\n        else:\n            message = (\n                f\"Message '{self.text}', sent by user @{self.sender.profile.real_name} in channel #{self.channel.name}\"\n            )\n        return message\n\n    def __repr__(self) -&gt; str:\n        return f\"Message(text={self.text!r}, sender={self.sender.profile.real_name!r}, channel={self.channel.name!r})\"\n</code></pre>"},{"location":"api/#machine.plugins.message.Message.sender","title":"<code>sender: User</code>  <code>property</code>","text":"<p>The sender of the message</p> <p>Returns:</p> Type Description <code>User</code> <p>the User the message was sent by</p>"},{"location":"api/#machine.plugins.message.Message.channel","title":"<code>channel: Channel</code>  <code>property</code>","text":"<p>The channel the message was sent to</p> <p>Returns:</p> Type Description <code>Channel</code> <p>the Channel the message was sent to</p>"},{"location":"api/#machine.plugins.message.Message.is_dm","title":"<code>is_dm: bool</code>  <code>property</code>","text":"<p>Is the message a direct message</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the message was not sent in a channel or group, <code>False</code> otherwise</p>"},{"location":"api/#machine.plugins.message.Message.text","title":"<code>text: str</code>  <code>property</code>","text":"<p>The body of the actual message</p> <p>Returns:</p> Type Description <code>str</code> <p>the body (text) of the actual message</p>"},{"location":"api/#machine.plugins.message.Message.at_sender","title":"<code>at_sender: str</code>  <code>property</code>","text":"<p>The sender of the message formatted as mention</p> <p>Returns:</p> Type Description <code>str</code> <p>a string representation of the sender of the message, formatted as mention, to be used in messages</p>"},{"location":"api/#machine.plugins.message.Message.ts","title":"<code>ts: str</code>  <code>property</code>","text":"<p>The timestamp of the message</p> <p>Returns:</p> Type Description <code>str</code> <p>the timestamp of the message</p>"},{"location":"api/#machine.plugins.message.Message.in_thread","title":"<code>in_thread: bool</code>  <code>property</code>","text":"<p>Is message in a thread</p> <p>Returns:</p> Type Description <code>bool</code> <p>the message is in a thread</p>"},{"location":"api/#machine.plugins.message.Message.say","title":"<code>say(text: str | None = None, attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None, blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None, thread_ts: str | None = None, ephemeral: bool = False, **kwargs: Any) -&gt; AsyncSlackResponse</code>  <code>async</code>","text":"<p>Send a new message to the channel the original message was received in</p> <p>Send a new message to the channel the original message was received in, using the WebAPI. Allows for rich formatting using blocks and/or attachments. You can provide blocks and attachments as Python dicts or you can use the convenience classes that the underlying slack client provides. Can also reply to a thread and send an ephemeral message only visible to the sender of the original message. Ephemeral messages and threaded messages are mutually exclusive, and <code>ephemeral</code> takes precedence over <code>thread_ts</code> Any extra kwargs you provide, will be passed on directly to the chat.postMessage or chat.postEphemeral request.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str | None</code> <p>message text</p> <code>None</code> <code>attachments</code> <code>Sequence[Attachment] | Sequence[dict[str, Any]] | None</code> <p>optional attachments (see attachments)</p> <code>None</code> <code>blocks</code> <code>Sequence[Block] | Sequence[dict[str, Any]] | None</code> <p>optional blocks (see blocks)</p> <code>None</code> <code>thread_ts</code> <code>str | None</code> <p>optional timestamp of thread, to send a message in that thread</p> <code>None</code> <code>ephemeral</code> <code>bool</code> <p><code>True/False</code> wether to send the message as an ephemeral message, only visible to the sender of the original message</p> <code>False</code> <p>Returns:</p> Type Description <code>AsyncSlackResponse</code> <p>Dictionary deserialized from chat.postMessage response, or chat.postEphemeral if <code>ephemeral</code> is True.</p> Source code in <code>src/machine/plugins/message.py</code> <pre><code>async def say(\n    self,\n    text: str | None = None,\n    attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None,\n    blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None,\n    thread_ts: str | None = None,\n    ephemeral: bool = False,\n    **kwargs: Any,\n) -&gt; AsyncSlackResponse:\n    \"\"\"Send a new message to the channel the original message was received in\n\n    Send a new message to the channel the original message was received in, using the WebAPI.\n    Allows for rich formatting using [blocks] and/or [attachments]. You can provide blocks\n    and attachments as Python dicts or you can use the [convenience classes] that the\n    underlying slack client provides.\n    Can also reply to a thread and send an ephemeral message only visible to the sender of the\n    original message. Ephemeral messages and threaded messages are mutually exclusive, and\n    `ephemeral` takes precedence over `thread_ts`\n    Any extra kwargs you provide, will be passed on directly to the [chat.postMessage] or\n    [chat.postEphemeral] request.\n\n    [attachments]: https://api.slack.com/docs/message-attachments\n    [blocks]: https://api.slack.com/reference/block-kit/blocks\n    [convenience classes]:\n        https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes\n    [chat.postMessage]: https://api.slack.com/methods/chat.postMessage\n    [chat.postEphemeral]: https://api.slack.com/methods/chat.postEphemeral\n\n    Args:\n        text: message text\n        attachments: optional attachments (see [attachments](https://api.slack.com/docs/message-attachments))\n        blocks: optional blocks (see [blocks](https://api.slack.com/reference/block-kit/blocks))\n        thread_ts: optional timestamp of thread, to send a message in that thread\n        ephemeral: `True/False` wether to send the message as an ephemeral message, only\n            visible to the sender of the original message\n\n    Returns:\n        Dictionary deserialized from [chat.postMessage](https://api.slack.com/methods/chat.postMessage) response,\n            or [chat.postEphemeral](https://api.slack.com/methods/chat.postEphemeral) if `ephemeral` is True.\n\n\n    \"\"\"\n    ephemeral_user = self.sender.id if ephemeral else None\n\n    return await self._client.send(\n        self.channel.id,\n        text=text,\n        attachments=attachments,\n        blocks=blocks,\n        thread_ts=thread_ts,\n        ephemeral_user=ephemeral_user,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/#machine.plugins.message.Message.say_scheduled","title":"<code>say_scheduled(when: datetime, text: str, attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None, blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None, thread_ts: str | None = None, **kwargs: Any) -&gt; AsyncSlackResponse</code>  <code>async</code>","text":"<p>Schedule a message</p> <p>This is the scheduled version of <code>say()</code>. It behaves the same, but will send the message at the scheduled time.</p> <p>Parameters:</p> Name Type Description Default <code>when</code> <code>datetime</code> <p>when you want the message to be sent, as <code>datetime</code> instance</p> required <code>text</code> <code>str</code> <p>message text</p> required <code>attachments</code> <code>Sequence[Attachment] | Sequence[dict[str, Any]] | None</code> <p>optional attachments (see attachments)</p> <code>None</code> <code>blocks</code> <code>Sequence[Block] | Sequence[dict[str, Any]] | None</code> <p>optional blocks (see blocks)</p> <code>None</code> <code>thread_ts</code> <code>str | None</code> <p>optional timestamp of thread, to send a message in that thread</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncSlackResponse</code> <p>Dictionary deserialized from chat.scheduleMessage response.</p> Source code in <code>src/machine/plugins/message.py</code> <pre><code>async def say_scheduled(\n    self,\n    when: datetime,\n    text: str,\n    attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None,\n    blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None,\n    thread_ts: str | None = None,\n    **kwargs: Any,\n) -&gt; AsyncSlackResponse:\n    \"\"\"Schedule a message\n\n    This is the scheduled version of [`say()`][machine.plugins.message.Message.say].\n    It behaves the same, but will send the message at the scheduled time.\n\n    Args:\n        when: when you want the message to be sent, as [`datetime`][datetime.datetime] instance\n        text: message text\n        attachments: optional attachments (see [attachments](https://api.slack.com/docs/message-attachments))\n        blocks: optional blocks (see [blocks](https://api.slack.com/reference/block-kit/blocks))\n        thread_ts: optional timestamp of thread, to send a message in that thread\n\n    Returns:\n        Dictionary deserialized from [chat.scheduleMessage](https://api.slack.com/methods/chat.scheduleMessage)\n            response.\n    \"\"\"\n    return await self._client.send_scheduled(\n        when,\n        self.channel.id,\n        text=text,\n        attachments=attachments,\n        blocks=blocks,\n        thread_ts=thread_ts,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/#machine.plugins.message.Message.reply","title":"<code>reply(text: str | None = None, attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None, blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None, in_thread: bool = False, ephemeral: bool = False, **kwargs: Any) -&gt; AsyncSlackResponse</code>  <code>async</code>","text":"<p>Reply to the sender of the original message</p> <p>Reply to the sender of the original message with a new message, mentioning that user. Rich formatting using blocks and/or attachments is possible. You can provide blocks and attachments as Python dicts or you can use the convenience classes that the underlying slack client provides. Can also reply to a thread and send an ephemeral message only visible to the sender of the original message. In the case of in-thread response, the sender of the original message will not be mentioned. Ephemeral messages and threaded messages are mutually exclusive, and <code>ephemeral</code> takes precedence over <code>in_thread</code> Any extra kwargs you provide, will be passed on directly to the chat.postMessage or chat.postEphemeral request.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str | None</code> <p>message text</p> <code>None</code> <code>attachments</code> <code>Sequence[Attachment] | Sequence[dict[str, Any]] | None</code> <p>optional attachments (see attachments)</p> <code>None</code> <code>blocks</code> <code>Sequence[Block] | Sequence[dict[str, Any]] | None</code> <p>optional blocks (see blocks</p> <code>None</code> <code>in_thread</code> <code>bool</code> <p><code>True/False</code> wether to reply to the original message in-thread</p> <code>False</code> <code>ephemeral</code> <code>bool</code> <p><code>True/False</code> wether to send the message as an ephemeral message, only visible to the sender of the original message</p> <code>False</code> <p>Returns:</p> Type Description <code>AsyncSlackResponse</code> <p>Dictionary deserialized from chat.postMessage response, or chat.postEphemeral if <code>ephemeral</code> is True.</p> Source code in <code>src/machine/plugins/message.py</code> <pre><code>async def reply(\n    self,\n    text: str | None = None,\n    attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None,\n    blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None,\n    in_thread: bool = False,\n    ephemeral: bool = False,\n    **kwargs: Any,\n) -&gt; AsyncSlackResponse:\n    \"\"\"Reply to the sender of the original message\n\n    Reply to the sender of the original message with a new message, mentioning that user. Rich\n    formatting using [blocks] and/or [attachments] is possible. You can provide blocks\n    and attachments as Python dicts or you can use the [convenience classes] that the\n    underlying slack client provides.\n    Can also reply to a thread and send an ephemeral message only visible to the sender of the\n    original message. In the case of in-thread response, the sender of the original message\n    will not be mentioned. Ephemeral messages and threaded messages are mutually exclusive,\n    and `ephemeral` takes precedence over `in_thread`\n    Any extra kwargs you provide, will be passed on directly to the [chat.postMessage] or\n    [chat.postEphemeral] request.\n\n    [attachments]: https://api.slack.com/docs/message-attachments\n    [blocks]: https://api.slack.com/reference/block-kit/blocks\n    [convenience classes]:\n        https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes\n    [chat.postMessage]: https://api.slack.com/methods/chat.postMessage\n    [chat.postEphemeral]: https://api.slack.com/methods/chat.postEphemeral\n\n    Args:\n        text: message text\n        attachments: optional attachments (see [attachments](https://api.slack.com/docs/message-attachments))\n        blocks: optional blocks (see [blocks](https://api.slack.com/reference/block-kit/blocks)\n        in_thread: `True/False` wether to reply to the original message in-thread\n        ephemeral: `True/False` wether to send the message as an ephemeral message, only\n            visible to the sender of the original message\n\n    Returns:\n        Dictionary deserialized from [chat.postMessage](https://api.slack.com/methods/chat.postMessage) response,\n            or [chat.postEphemeral](https://api.slack.com/methods/chat.postEphemeral) if `ephemeral` is True.\n    \"\"\"\n    if in_thread and not ephemeral:\n        return await self.say(text, attachments=attachments, blocks=blocks, thread_ts=self.ts, **kwargs)\n    else:\n        text = self._create_reply(text)\n        return await self.say(text, attachments=attachments, blocks=blocks, ephemeral=ephemeral, **kwargs)\n</code></pre>"},{"location":"api/#machine.plugins.message.Message.reply_scheduled","title":"<code>reply_scheduled(when: datetime, text: str, attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None, blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None, in_thread: bool = False, **kwargs: Any) -&gt; AsyncSlackResponse</code>  <code>async</code>","text":"<p>Schedule a reply and send it</p> <p>This is the scheduled version of <code>reply()</code>. It behaves the same, but will send the reply at the scheduled time.</p> <p>Parameters:</p> Name Type Description Default <code>when</code> <code>datetime</code> <p>when you want the message to be sent, as :py:class:<code>datetime.datetime</code> instance</p> required <code>text</code> <code>str</code> <p>message text</p> required <code>attachments</code> <code>Sequence[Attachment] | Sequence[dict[str, Any]] | None</code> <p>optional attachments (see attachments)</p> <code>None</code> <code>blocks</code> <code>Sequence[Block] | Sequence[dict[str, Any]] | None</code> <p>optional blocks (see blocks)</p> <code>None</code> <code>in_thread</code> <code>bool</code> <p><code>True/False</code> wether to reply to the original message in-thread</p> <code>False</code> <p>Returns:</p> Type Description <code>AsyncSlackResponse</code> <p>Dictionary deserialized from chat.scheduleMessage response.</p> Source code in <code>src/machine/plugins/message.py</code> <pre><code>async def reply_scheduled(\n    self,\n    when: datetime,\n    text: str,\n    attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None,\n    blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None,\n    in_thread: bool = False,\n    **kwargs: Any,\n) -&gt; AsyncSlackResponse:\n    \"\"\"Schedule a reply and send it\n\n    This is the scheduled version of [`reply()`][machine.plugins.message.Message.reply].\n    It behaves the same, but will send the reply at the scheduled time.\n\n    Args:\n        when: when you want the message to be sent, as :py:class:`datetime.datetime` instance\n        text: message text\n        attachments: optional attachments (see [attachments](https://api.slack.com/docs/message-attachments))\n        blocks: optional blocks (see [blocks](https://api.slack.com/reference/block-kit/blocks))\n        in_thread: `True/False` wether to reply to the original message in-thread\n\n    Returns:\n        Dictionary deserialized from [chat.scheduleMessage](https://api.slack.com/methods/chat.scheduleMessage)\n            response.\n    \"\"\"\n    if in_thread:\n        return await self.say_scheduled(\n            when, text, attachments=attachments, blocks=blocks, thread_ts=self.ts, **kwargs\n        )\n    else:\n        text = cast(str, self._create_reply(text))\n        return await self.say_scheduled(when, text, attachments=attachments, blocks=blocks, **kwargs)\n</code></pre>"},{"location":"api/#machine.plugins.message.Message.reply_dm","title":"<code>reply_dm(text: str | None = None, attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None, blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None, **kwargs: Any) -&gt; AsyncSlackResponse</code>  <code>async</code>","text":"<p>Reply to the sender of the original message with a DM</p> <p>Reply in a Direct Message to the sender of the original message by opening a DM channel and sending a message to it. Allows for rich formatting using blocks and/or attachments. You can provide blocks and attachments as Python dicts or you can use the convenience classes that the underlying slack client provides. Any extra kwargs you provide, will be passed on directly to the chat.postMessage request.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str | None</code> <p>message text</p> <code>None</code> <code>attachments</code> <code>Sequence[Attachment] | Sequence[dict[str, Any]] | None</code> <p>optional attachments (see attachments)</p> <code>None</code> <code>blocks</code> <code>Sequence[Block] | Sequence[dict[str, Any]] | None</code> <p>optional blocks (see blocks)</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncSlackResponse</code> <p>Dictionary deserialized from chat.postMessage response.</p> Source code in <code>src/machine/plugins/message.py</code> <pre><code>async def reply_dm(\n    self,\n    text: str | None = None,\n    attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None,\n    blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None,\n    **kwargs: Any,\n) -&gt; AsyncSlackResponse:\n    \"\"\"Reply to the sender of the original message with a DM\n\n    Reply in a Direct Message to the sender of the original message by opening a DM channel and\n    sending a message to it. Allows for rich formatting using [blocks] and/or [attachments].\n    You can provide blocks and attachments as Python dicts or you can use the\n    [convenience classes] that the underlying slack client provides.\n    Any extra kwargs you provide, will be passed on directly to the [chat.postMessage] request.\n\n    [attachments]: https://api.slack.com/docs/message-attachments\n    [blocks]: https://api.slack.com/reference/block-kit/blocks\n    [convenience classes]:\n        https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes\n    [chat.postMessage]: https://api.slack.com/methods/chat.postMessage\n\n    Args:\n        text: message text\n        attachments: optional attachments (see [attachments](https://api.slack.com/docs/message-attachments))\n        blocks: optional blocks (see [blocks](https://api.slack.com/reference/block-kit/blocks))\n\n    Returns:\n        Dictionary deserialized from [chat.postMessage](https://api.slack.com/methods/chat.postMessage) response.\n    \"\"\"\n    return await self._client.send_dm(self.sender.id, text, attachments=attachments, blocks=blocks, **kwargs)\n</code></pre>"},{"location":"api/#machine.plugins.message.Message.reply_dm_scheduled","title":"<code>reply_dm_scheduled(when: datetime, text: str, attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None, blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None, **kwargs: Any) -&gt; AsyncSlackResponse</code>  <code>async</code>","text":"<p>Schedule a DM reply and send it</p> <p>This is the scheduled version of <code>reply_dm()</code>. It behaves the same, but will send the DM at the scheduled time.</p> <p>Parameters:</p> Name Type Description Default <code>when</code> <code>datetime</code> <p>when you want the message to be sent, as :py:class:<code>datetime.datetime</code> instance</p> required <code>text</code> <code>str</code> <p>message text</p> required <code>attachments</code> <code>Sequence[Attachment] | Sequence[dict[str, Any]] | None</code> <p>optional attachments (see attachments)</p> <code>None</code> <code>blocks</code> <code>Sequence[Block] | Sequence[dict[str, Any]] | None</code> <p>optional blocks (see blocks)</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncSlackResponse</code> <p>Dictionary deserialized from chat.scheduleMessage response.</p> Source code in <code>src/machine/plugins/message.py</code> <pre><code>async def reply_dm_scheduled(\n    self,\n    when: datetime,\n    text: str,\n    attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None,\n    blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None,\n    **kwargs: Any,\n) -&gt; AsyncSlackResponse:\n    \"\"\"Schedule a DM reply and send it\n\n    This is the scheduled version of [`reply_dm()`][machine.plugins.message.Message.reply_dm].\n    It behaves the same, but will send the DM at the scheduled time.\n\n    Args:\n        when: when you want the message to be sent, as :py:class:`datetime.datetime` instance\n        text: message text\n        attachments: optional attachments (see [attachments](https://api.slack.com/docs/message-attachments))\n        blocks: optional blocks (see [blocks](https://api.slack.com/reference/block-kit/blocks))\n\n    Returns:\n        Dictionary deserialized from [chat.scheduleMessage](https://api.slack.com/methods/chat.scheduleMessage)\n            response.\n    \"\"\"\n    return await self._client.send_dm_scheduled(\n        when, self.sender.id, text=text, attachments=attachments, blocks=blocks, **kwargs\n    )\n</code></pre>"},{"location":"api/#machine.plugins.message.Message.react","title":"<code>react(emoji: str) -&gt; AsyncSlackResponse</code>  <code>async</code>","text":"<p>React to the original message</p> <p>Add a reaction to the original message</p> <p>Parameters:</p> Name Type Description Default <code>emoji</code> <code>str</code> <p>what emoji to react with (should be a string, like 'angel', 'thumbsup', etc.)</p> required <p>Returns:</p> Type Description <code>AsyncSlackResponse</code> <p>Dictionary deserialized from reactions.add response.</p> Source code in <code>src/machine/plugins/message.py</code> <pre><code>async def react(self, emoji: str) -&gt; AsyncSlackResponse:\n    \"\"\"React to the original message\n\n    Add a reaction to the original message\n\n    Args:\n        emoji: what emoji to react with (should be a string, like 'angel', 'thumbsup', etc.)\n\n    Returns:\n        Dictionary deserialized from [reactions.add](https://api.slack.com/methods/reactions.add) response.\n    \"\"\"\n    return await self._client.react(self.channel.id, self._msg_event[\"ts\"], emoji)\n</code></pre>"},{"location":"api/#machine.plugins.message.Message.pin_message","title":"<code>pin_message() -&gt; AsyncSlackResponse</code>  <code>async</code>","text":"<p>Pin message</p> <p>Pin the current message in the channel it was posted in</p> <p>Returns:</p> Type Description <code>AsyncSlackResponse</code> <p>Dictionary deserialized from pins.add response.</p> Source code in <code>src/machine/plugins/message.py</code> <pre><code>async def pin_message(self) -&gt; AsyncSlackResponse:\n    \"\"\"Pin message\n\n    Pin the current message in the channel it was posted in\n\n    Returns:\n        Dictionary deserialized from [pins.add](https://api.slack.com/methods/pins.add) response.\n    \"\"\"\n    return await self._client.pin_message(self.channel, self.ts)\n</code></pre>"},{"location":"api/#machine.plugins.command.Command","title":"<code>machine.plugins.command.Command</code>","text":"<p>A Slack command that was received by the bot</p> <p>This class represents a Slack command that was received by the bot and passed to a plugin. It contains the text that was included when the command was invoked, and metadata about the command, such as the user that invoked the command, the channel the command was invoked in.</p> <p>The <code>Command</code> class also contains convenience methods for sending messages in the right channel, opening modals etc.</p> Source code in <code>src/machine/plugins/command.py</code> <pre><code>class Command:\n    \"\"\"A Slack command that was received by the bot\n\n    This class represents a Slack command that was received by the bot and passed to a plugin.\n    It contains the text that was included when the command was invoked, and metadata about\n    the command, such as the user that invoked the command, the channel the command was invoked\n    in.\n\n    The `Command` class also contains convenience methods for sending messages in the right\n    channel, opening modals etc.\n    \"\"\"\n\n    # TODO: create proper class for cmd_event\n    def __init__(self, client: SlackClient, cmd_payload: dict[str, Any]):\n        self._client = client\n        self._cmd_payload = cmd_payload\n        self._webhook_client = AsyncWebhookClient(self._cmd_payload[\"response_url\"])\n\n    @property\n    def sender(self) -&gt; User:\n        \"\"\"The user that invoked the command\n\n        Returns:\n            the User that invoked the command\n        \"\"\"\n        return self._client.users[self._cmd_payload[\"user_id\"]]\n\n    @property\n    def channel(self) -&gt; Channel:\n        \"\"\"The channel the command was invoked in\n\n        Returns:\n            the Channel the command was invoked in\n        \"\"\"\n        return self._client.channels[self._cmd_payload[\"channel_id\"]]\n\n    @property\n    def is_dm(self) -&gt; bool:\n        \"\"\"Whether the command was invoked in a DM\n\n        Returns:\n            `True` if the message was _not_ invoked in a channel or group, `False` otherwise\n        \"\"\"\n        channel_id = self._cmd_payload[\"channel_id\"]\n        return not (channel_id.startswith(\"C\") or channel_id.startswith(\"G\"))\n\n    @property\n    def text(self) -&gt; str:\n        \"\"\"The body of the command (i.e. anything after the command itself)\n\n        Returns:\n            the body (text) of the command\n        \"\"\"\n        return self._cmd_payload[\"text\"]\n\n    @property\n    def command(self) -&gt; str:\n        \"\"\"The command that was invoked\n\n        Returns:\n            the command that was invoked\n        \"\"\"\n        return self._cmd_payload[\"command\"]\n\n    @property\n    def response_url(self) -&gt; str:\n        \"\"\"The response url associated with the command\n\n        This is a unique url for this specific command invocation.\n        It can be used for sending messages in response to the command.\n        This can only be used 5 times within 30 minutes of receiving the payload.\n\n        Returns:\n            the response url associated with the command\n        \"\"\"\n        return self._cmd_payload[\"response_url\"]\n\n    @property\n    def trigger_id(self) -&gt; str:\n        \"\"\"The trigger id associated with the command\n\n        The trigger id can be used to trigger modals\n\n        Note:\n            The `trigger_id` is only valid for 3 seconds after the modal was submitted.\n\n            You can use [`open_modal`][machine.plugins.command.Command.open_modal] to open a modal instead of using\n            the `trigger_id` directly.\n\n        Returns:\n            the trigger id associated with the command\n        \"\"\"\n        return self._cmd_payload[\"trigger_id\"]\n\n    async def say(\n        self,\n        text: str | None = None,\n        attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None,\n        blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None,\n        ephemeral: bool = True,\n        **kwargs: Any,\n    ) -&gt; WebhookResponse:\n        \"\"\"Send a new message to the channel the command was invoked in\n\n        Send a new message to the channel the command was invoked in, using the response_url as a webhook.\n        Allows for rich formatting using [blocks] and/or [attachments] . You can provide blocks\n        and attachments as Python dicts or you can use the [convenience classes] that the\n        underlying slack client provides.\n        This will send an ephemeral message by default, only visible to the user that invoked the command.\n        You can set `ephemeral` to `False` to make the message visible to everyone in the channel\n        Any extra kwargs you provide, will be passed on directly to `AsyncWebhookClient.send()`\n\n        [attachments]: https://api.slack.com/docs/message-attachments\n        [blocks]: https://api.slack.com/reference/block-kit/blocks\n        [convenience classes]: https://github.com/slackapi/python-slack-sdk/tree/main/slack/web/classes\n\n        Args:\n            text: message text\n            attachments: optional attachments (see [attachments](https://api.slack.com/docs/message-attachments))\n            blocks: optional blocks (see [blocks](https://api.slack.com/reference/block-kit/blocks))\n            ephemeral: `True/False` wether to send the message as an ephemeral message, only\n                visible to the sender of the original message\n\n        Returns:\n            Dictionary deserialized from `AsyncWebhookClient.send()`\n        \"\"\"\n        response_type = \"ephemeral\" if ephemeral else \"in_channel\"\n\n        return await self._webhook_client.send(\n            text=text, attachments=attachments, blocks=blocks, response_type=response_type, **kwargs\n        )\n\n    async def open_modal(\n        self,\n        view: dict | View,\n        **kwargs: Any,\n    ) -&gt; AsyncSlackResponse:\n        \"\"\"Open a modal in response to the command\n\n        Open a modal in response to the command, using the trigger_id that was returned when the command was invoked.\n        Any extra kwargs you provide, will be passed on directly to `AsyncWebClient.views_open()`\n\n        Note:\n            You have to call this method within 3 seconds of receiving the command payload.\n\n        Args:\n            view: the view to open\n\n        Returns:\n            Dictionary deserialized from `AsyncWebClient.views_open()`\n        \"\"\"\n        return await self._client.open_modal(self.trigger_id, view, **kwargs)\n</code></pre>"},{"location":"api/#machine.plugins.command.Command.sender","title":"<code>sender: User</code>  <code>property</code>","text":"<p>The user that invoked the command</p> <p>Returns:</p> Type Description <code>User</code> <p>the User that invoked the command</p>"},{"location":"api/#machine.plugins.command.Command.channel","title":"<code>channel: Channel</code>  <code>property</code>","text":"<p>The channel the command was invoked in</p> <p>Returns:</p> Type Description <code>Channel</code> <p>the Channel the command was invoked in</p>"},{"location":"api/#machine.plugins.command.Command.is_dm","title":"<code>is_dm: bool</code>  <code>property</code>","text":"<p>Whether the command was invoked in a DM</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the message was not invoked in a channel or group, <code>False</code> otherwise</p>"},{"location":"api/#machine.plugins.command.Command.text","title":"<code>text: str</code>  <code>property</code>","text":"<p>The body of the command (i.e. anything after the command itself)</p> <p>Returns:</p> Type Description <code>str</code> <p>the body (text) of the command</p>"},{"location":"api/#machine.plugins.command.Command.command","title":"<code>command: str</code>  <code>property</code>","text":"<p>The command that was invoked</p> <p>Returns:</p> Type Description <code>str</code> <p>the command that was invoked</p>"},{"location":"api/#machine.plugins.command.Command.response_url","title":"<code>response_url: str</code>  <code>property</code>","text":"<p>The response url associated with the command</p> <p>This is a unique url for this specific command invocation. It can be used for sending messages in response to the command. This can only be used 5 times within 30 minutes of receiving the payload.</p> <p>Returns:</p> Type Description <code>str</code> <p>the response url associated with the command</p>"},{"location":"api/#machine.plugins.command.Command.trigger_id","title":"<code>trigger_id: str</code>  <code>property</code>","text":"<p>The trigger id associated with the command</p> <p>The trigger id can be used to trigger modals</p> Note <p>The <code>trigger_id</code> is only valid for 3 seconds after the modal was submitted.</p> <p>You can use <code>open_modal</code> to open a modal instead of using the <code>trigger_id</code> directly.</p> <p>Returns:</p> Type Description <code>str</code> <p>the trigger id associated with the command</p>"},{"location":"api/#machine.plugins.command.Command.say","title":"<code>say(text: str | None = None, attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None, blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None, ephemeral: bool = True, **kwargs: Any) -&gt; WebhookResponse</code>  <code>async</code>","text":"<p>Send a new message to the channel the command was invoked in</p> <p>Send a new message to the channel the command was invoked in, using the response_url as a webhook. Allows for rich formatting using blocks and/or attachments . You can provide blocks and attachments as Python dicts or you can use the convenience classes that the underlying slack client provides. This will send an ephemeral message by default, only visible to the user that invoked the command. You can set <code>ephemeral</code> to <code>False</code> to make the message visible to everyone in the channel Any extra kwargs you provide, will be passed on directly to <code>AsyncWebhookClient.send()</code></p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str | None</code> <p>message text</p> <code>None</code> <code>attachments</code> <code>Sequence[Attachment] | Sequence[dict[str, Any]] | None</code> <p>optional attachments (see attachments)</p> <code>None</code> <code>blocks</code> <code>Sequence[Block] | Sequence[dict[str, Any]] | None</code> <p>optional blocks (see blocks)</p> <code>None</code> <code>ephemeral</code> <code>bool</code> <p><code>True/False</code> wether to send the message as an ephemeral message, only visible to the sender of the original message</p> <code>True</code> <p>Returns:</p> Type Description <code>WebhookResponse</code> <p>Dictionary deserialized from <code>AsyncWebhookClient.send()</code></p> Source code in <code>src/machine/plugins/command.py</code> <pre><code>async def say(\n    self,\n    text: str | None = None,\n    attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None,\n    blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None,\n    ephemeral: bool = True,\n    **kwargs: Any,\n) -&gt; WebhookResponse:\n    \"\"\"Send a new message to the channel the command was invoked in\n\n    Send a new message to the channel the command was invoked in, using the response_url as a webhook.\n    Allows for rich formatting using [blocks] and/or [attachments] . You can provide blocks\n    and attachments as Python dicts or you can use the [convenience classes] that the\n    underlying slack client provides.\n    This will send an ephemeral message by default, only visible to the user that invoked the command.\n    You can set `ephemeral` to `False` to make the message visible to everyone in the channel\n    Any extra kwargs you provide, will be passed on directly to `AsyncWebhookClient.send()`\n\n    [attachments]: https://api.slack.com/docs/message-attachments\n    [blocks]: https://api.slack.com/reference/block-kit/blocks\n    [convenience classes]: https://github.com/slackapi/python-slack-sdk/tree/main/slack/web/classes\n\n    Args:\n        text: message text\n        attachments: optional attachments (see [attachments](https://api.slack.com/docs/message-attachments))\n        blocks: optional blocks (see [blocks](https://api.slack.com/reference/block-kit/blocks))\n        ephemeral: `True/False` wether to send the message as an ephemeral message, only\n            visible to the sender of the original message\n\n    Returns:\n        Dictionary deserialized from `AsyncWebhookClient.send()`\n    \"\"\"\n    response_type = \"ephemeral\" if ephemeral else \"in_channel\"\n\n    return await self._webhook_client.send(\n        text=text, attachments=attachments, blocks=blocks, response_type=response_type, **kwargs\n    )\n</code></pre>"},{"location":"api/#machine.plugins.command.Command.open_modal","title":"<code>open_modal(view: dict | View, **kwargs: Any) -&gt; AsyncSlackResponse</code>  <code>async</code>","text":"<p>Open a modal in response to the command</p> <p>Open a modal in response to the command, using the trigger_id that was returned when the command was invoked. Any extra kwargs you provide, will be passed on directly to <code>AsyncWebClient.views_open()</code></p> Note <p>You have to call this method within 3 seconds of receiving the command payload.</p> <p>Parameters:</p> Name Type Description Default <code>view</code> <code>dict | View</code> <p>the view to open</p> required <p>Returns:</p> Type Description <code>AsyncSlackResponse</code> <p>Dictionary deserialized from <code>AsyncWebClient.views_open()</code></p> Source code in <code>src/machine/plugins/command.py</code> <pre><code>async def open_modal(\n    self,\n    view: dict | View,\n    **kwargs: Any,\n) -&gt; AsyncSlackResponse:\n    \"\"\"Open a modal in response to the command\n\n    Open a modal in response to the command, using the trigger_id that was returned when the command was invoked.\n    Any extra kwargs you provide, will be passed on directly to `AsyncWebClient.views_open()`\n\n    Note:\n        You have to call this method within 3 seconds of receiving the command payload.\n\n    Args:\n        view: the view to open\n\n    Returns:\n        Dictionary deserialized from `AsyncWebClient.views_open()`\n    \"\"\"\n    return await self._client.open_modal(self.trigger_id, view, **kwargs)\n</code></pre>"},{"location":"api/#machine.plugins.block_action.BlockAction","title":"<code>machine.plugins.block_action.BlockAction</code>","text":"<p>A Slack block action that was received by the bot</p> <p>This class represents a block action that was received by the bot and passed to a plugin. Block actions are actions that are triggered by interactions with blocks in Slack messages and modals. This class contains metadata about the block action, such as the action that happened that triggered this handler, the user that triggered the action, the state of the block when the action was triggered, the payload that was received when the action was triggered.</p> <p>Attributes:</p> Name Type Description <code>payload</code> <code>BlockActionsPayload</code> <p>The payload that was received by the bot when the action was triggered that this plugin method listens for</p> <code>triggered_action</code> <code>Action</code> <p>The action that triggered this plugin method</p> Source code in <code>src/machine/plugins/block_action.py</code> <pre><code>class BlockAction:\n    \"\"\"A Slack block action that was received by the bot\n\n    This class represents a block action that was received by the bot and passed to a plugin.\n    Block actions are actions that are triggered by interactions with blocks in Slack messages and modals.\n    This class contains metadata about the block action, such as the action that happened that triggered this handler,\n    the user that triggered the action, the state of the block when the action was triggered, the payload that was\n    received when the action was triggered.\n\n    Attributes:\n        payload: The payload that was received by the bot when the action was triggered that this\n            plugin method listens for\n        triggered_action: The action that triggered this plugin method\n    \"\"\"\n\n    payload: BlockActionsPayload\n    triggered_action: Action\n\n    def __init__(self, client: SlackClient, payload: BlockActionsPayload, triggered_action: Action):\n        self._client = client\n        self.payload = payload\n        \"\"\"The payload that was received by the bot when the action was triggered that this plugin method listens for\"\"\"\n        self.triggered_action = triggered_action\n        \"\"\"The action that triggered this plugin method\"\"\"\n        self._webhook_client = AsyncWebhookClient(self.payload.response_url) if self.payload.response_url else None\n\n    @property\n    def user(self) -&gt; User:\n        \"\"\"The user that triggered the action\n\n        Returns:\n            the user that triggered the action\n        \"\"\"\n        return self._client.users[self.payload.user.id]\n\n    @property\n    def channel(self) -&gt; Channel | None:\n        \"\"\"The channel the action was triggered in\n\n        Returns:\n            the channel the action was triggered in or None if the action was triggered in a modal\n        \"\"\"\n        if self.payload.channel is None:\n            return None\n        return self._client.channels[self.payload.channel.id]\n\n    @property\n    def state(self) -&gt; State | None:\n        \"\"\"The state of the block when the action was triggered\n\n        Returns:\n            the state of the block when the action was triggered\n        \"\"\"\n        return self.payload.state\n\n    @property\n    def response_url(self) -&gt; str | None:\n        \"\"\"The response URL for the action\n\n        Returns:\n            the response URL for the action or `None` if the action was triggered in a modal\n        \"\"\"\n        return self.payload.response_url\n\n    @property\n    def trigger_id(self) -&gt; str:\n        \"\"\"The trigger id associated with the action\n\n        The trigger id can be used to open a modal\n\n        Note:\n            The `trigger_id` is only valid for 3 seconds after the modal was submitted.\n\n            You can use [`open_modal`][machine.plugins.block_action.BlockAction.open_modal] to open a modal instead of\n            using the `trigger_id` directly.\n\n        Returns:\n            the trigger id for the action\n        \"\"\"\n        return self.payload.trigger_id\n\n    async def say(\n        self,\n        text: str | None = None,\n        attachments: Union[Sequence[Attachment], Sequence[dict[str, Any]], None] = None,\n        blocks: Union[Sequence[Block], Sequence[dict[str, Any]], None] = None,\n        ephemeral: bool = True,\n        replace_original: bool = False,\n        delete_original: bool = False,\n        **kwargs: Any,\n    ) -&gt; WebhookResponse | None:\n        \"\"\"Send a new message to the channel the block action was triggered in\n\n        Send a new message to the channel the block action was triggered in, using the response_url as a webhook.\n        If the block action happened in a modal, the response_url will be None and this method will not send a message\n        but instead log a warning.\n        Allows for rich formatting using [blocks] and/or [attachments]. You can provide blocks\n        and attachments as Python dicts or you can use the [convenience classes] that the\n        underlying slack client provides.\n        This will send an ephemeral message by default, only visible to the user that triggered the action.\n        You can set `ephemeral` to `False` to make the message visible to everyone in the channel.\n        By default, Slack replaces the original message in which the action was triggered. This method overrides this\n        behavior. If you want your message to replace the original, set replace_original to True.\n        Any extra kwargs you provide, will be passed on directly to `AsyncWebhookClient.send()`\n\n        [attachments]: https://api.slack.com/docs/message-attachments\n        [blocks]: https://api.slack.com/reference/block-kit/blocks\n        [convenience classes]: https://github.com/slackapi/python-slack-sdk/tree/main/slack/web/classes\n\n        Args:\n            text: message text\n            attachments: optional attachments (see [attachments](https://api.slack.com/docs/message-attachments))\n            blocks: optional blocks (see [blocks](https://api.slack.com/docs/message-attachments))\n            ephemeral: `True/False` wether to send the message as an ephemeral message, only\n                visible to the user that initiated the action\n            replace_original: `True/False` whether the message that contains the block from which the action was\n                triggered should be replaced by this message\n            delete_original: `True/False` whether the message that contains the block from which the action was\n                triggered should be deleted. No other parameters should be provided.\n\n        Returns:\n            Dictionary deserialized from `AsyncWebhookClient.send()`\n\n        \"\"\"\n        if self._webhook_client is None:\n            logger.warning(\n                \"response_url is None, cannot send message. This likely means the action was triggered in a modal.\"\n            )\n            return None\n\n        response_type = \"ephemeral\" if ephemeral else \"in_channel\"\n        return await self._webhook_client.send(\n            text=text,\n            attachments=attachments,\n            blocks=blocks,\n            response_type=response_type,\n            replace_original=replace_original,\n            delete_original=delete_original,\n            **kwargs,\n        )\n\n    async def send_dm(\n        self,\n        text: str | None = None,\n        attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None,\n        blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None,\n        **kwargs: Any,\n    ) -&gt; AsyncSlackResponse:\n        \"\"\"Send a DM to the user that triggered the block action\n\n        Send a Direct Message to the user that triggered the block action by opening a DM channel and\n        sending a message to it.\n        Allows for rich formatting using [blocks] and/or [attachments]. You can provide blocks\n        and attachments as Python dicts or you can use the [convenience classes] that the\n        underlying slack client provides.\n        Any extra kwargs you provide, will be passed on directly to the `chat.postMessage` request.\n\n        [attachments]: https://api.slack.com/docs/message-attachments\n        [blocks]: https://api.slack.com/reference/block-kit/blocks\n        [convenience classes]: https://github.com/slackapi/python-slack-sdk/tree/main/slack/web/classes\n\n        Args:\n            text: message text\n            attachments: optional attachments (see [attachments](https://api.slack.com/docs/message-attachments))\n            blocks: optional blocks (see [blocks](https://api.slack.com/reference/block-kit/blocks))\n\n        Returns:\n            Dictionary deserialized from [chat.postMessage](https://api.slack.com/methods/chat.postMessage) response.\n        \"\"\"\n        return await self._client.send_dm(self.user.id, text, attachments=attachments, blocks=blocks, **kwargs)\n\n    async def open_modal(\n        self,\n        view: dict | View,\n        **kwargs: Any,\n    ) -&gt; AsyncSlackResponse:\n        \"\"\"Open a modal in response to the block action\n\n        Open a modal in response to the block action, using the trigger_id that was returned when the block action was\n        triggered.\n        Any extra kwargs you provide, will be passed on directly to\n        [views.open](https://api.slack.com/methods/views.open)\n\n        Note:\n            You have to call this method within 3 seconds of receiving the block action payload.\n\n        Args:\n            view: the view to open\n\n        Returns:\n            Dictionary deserialized from [views.open](https://api.slack.com/methods/views.open)\n        \"\"\"\n        return await self._client.open_modal(self.trigger_id, view, **kwargs)\n</code></pre>"},{"location":"api/#machine.plugins.block_action.BlockAction.payload","title":"<code>payload: BlockActionsPayload = payload</code>  <code>instance-attribute</code>","text":"<p>The payload that was received by the bot when the action was triggered that this plugin method listens for</p>"},{"location":"api/#machine.plugins.block_action.BlockAction.triggered_action","title":"<code>triggered_action: Action = triggered_action</code>  <code>instance-attribute</code>","text":"<p>The action that triggered this plugin method</p>"},{"location":"api/#machine.plugins.block_action.BlockAction.user","title":"<code>user: User</code>  <code>property</code>","text":"<p>The user that triggered the action</p> <p>Returns:</p> Type Description <code>User</code> <p>the user that triggered the action</p>"},{"location":"api/#machine.plugins.block_action.BlockAction.channel","title":"<code>channel: Channel | None</code>  <code>property</code>","text":"<p>The channel the action was triggered in</p> <p>Returns:</p> Type Description <code>Channel | None</code> <p>the channel the action was triggered in or None if the action was triggered in a modal</p>"},{"location":"api/#machine.plugins.block_action.BlockAction.state","title":"<code>state: State | None</code>  <code>property</code>","text":"<p>The state of the block when the action was triggered</p> <p>Returns:</p> Type Description <code>State | None</code> <p>the state of the block when the action was triggered</p>"},{"location":"api/#machine.plugins.block_action.BlockAction.response_url","title":"<code>response_url: str | None</code>  <code>property</code>","text":"<p>The response URL for the action</p> <p>Returns:</p> Type Description <code>str | None</code> <p>the response URL for the action or <code>None</code> if the action was triggered in a modal</p>"},{"location":"api/#machine.plugins.block_action.BlockAction.trigger_id","title":"<code>trigger_id: str</code>  <code>property</code>","text":"<p>The trigger id associated with the action</p> <p>The trigger id can be used to open a modal</p> Note <p>The <code>trigger_id</code> is only valid for 3 seconds after the modal was submitted.</p> <p>You can use <code>open_modal</code> to open a modal instead of using the <code>trigger_id</code> directly.</p> <p>Returns:</p> Type Description <code>str</code> <p>the trigger id for the action</p>"},{"location":"api/#machine.plugins.block_action.BlockAction.say","title":"<code>say(text: str | None = None, attachments: Union[Sequence[Attachment], Sequence[dict[str, Any]], None] = None, blocks: Union[Sequence[Block], Sequence[dict[str, Any]], None] = None, ephemeral: bool = True, replace_original: bool = False, delete_original: bool = False, **kwargs: Any) -&gt; WebhookResponse | None</code>  <code>async</code>","text":"<p>Send a new message to the channel the block action was triggered in</p> <p>Send a new message to the channel the block action was triggered in, using the response_url as a webhook. If the block action happened in a modal, the response_url will be None and this method will not send a message but instead log a warning. Allows for rich formatting using blocks and/or attachments. You can provide blocks and attachments as Python dicts or you can use the convenience classes that the underlying slack client provides. This will send an ephemeral message by default, only visible to the user that triggered the action. You can set <code>ephemeral</code> to <code>False</code> to make the message visible to everyone in the channel. By default, Slack replaces the original message in which the action was triggered. This method overrides this behavior. If you want your message to replace the original, set replace_original to True. Any extra kwargs you provide, will be passed on directly to <code>AsyncWebhookClient.send()</code></p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str | None</code> <p>message text</p> <code>None</code> <code>attachments</code> <code>Union[Sequence[Attachment], Sequence[dict[str, Any]], None]</code> <p>optional attachments (see attachments)</p> <code>None</code> <code>blocks</code> <code>Union[Sequence[Block], Sequence[dict[str, Any]], None]</code> <p>optional blocks (see blocks)</p> <code>None</code> <code>ephemeral</code> <code>bool</code> <p><code>True/False</code> wether to send the message as an ephemeral message, only visible to the user that initiated the action</p> <code>True</code> <code>replace_original</code> <code>bool</code> <p><code>True/False</code> whether the message that contains the block from which the action was triggered should be replaced by this message</p> <code>False</code> <code>delete_original</code> <code>bool</code> <p><code>True/False</code> whether the message that contains the block from which the action was triggered should be deleted. No other parameters should be provided.</p> <code>False</code> <p>Returns:</p> Type Description <code>WebhookResponse | None</code> <p>Dictionary deserialized from <code>AsyncWebhookClient.send()</code></p> Source code in <code>src/machine/plugins/block_action.py</code> <pre><code>async def say(\n    self,\n    text: str | None = None,\n    attachments: Union[Sequence[Attachment], Sequence[dict[str, Any]], None] = None,\n    blocks: Union[Sequence[Block], Sequence[dict[str, Any]], None] = None,\n    ephemeral: bool = True,\n    replace_original: bool = False,\n    delete_original: bool = False,\n    **kwargs: Any,\n) -&gt; WebhookResponse | None:\n    \"\"\"Send a new message to the channel the block action was triggered in\n\n    Send a new message to the channel the block action was triggered in, using the response_url as a webhook.\n    If the block action happened in a modal, the response_url will be None and this method will not send a message\n    but instead log a warning.\n    Allows for rich formatting using [blocks] and/or [attachments]. You can provide blocks\n    and attachments as Python dicts or you can use the [convenience classes] that the\n    underlying slack client provides.\n    This will send an ephemeral message by default, only visible to the user that triggered the action.\n    You can set `ephemeral` to `False` to make the message visible to everyone in the channel.\n    By default, Slack replaces the original message in which the action was triggered. This method overrides this\n    behavior. If you want your message to replace the original, set replace_original to True.\n    Any extra kwargs you provide, will be passed on directly to `AsyncWebhookClient.send()`\n\n    [attachments]: https://api.slack.com/docs/message-attachments\n    [blocks]: https://api.slack.com/reference/block-kit/blocks\n    [convenience classes]: https://github.com/slackapi/python-slack-sdk/tree/main/slack/web/classes\n\n    Args:\n        text: message text\n        attachments: optional attachments (see [attachments](https://api.slack.com/docs/message-attachments))\n        blocks: optional blocks (see [blocks](https://api.slack.com/docs/message-attachments))\n        ephemeral: `True/False` wether to send the message as an ephemeral message, only\n            visible to the user that initiated the action\n        replace_original: `True/False` whether the message that contains the block from which the action was\n            triggered should be replaced by this message\n        delete_original: `True/False` whether the message that contains the block from which the action was\n            triggered should be deleted. No other parameters should be provided.\n\n    Returns:\n        Dictionary deserialized from `AsyncWebhookClient.send()`\n\n    \"\"\"\n    if self._webhook_client is None:\n        logger.warning(\n            \"response_url is None, cannot send message. This likely means the action was triggered in a modal.\"\n        )\n        return None\n\n    response_type = \"ephemeral\" if ephemeral else \"in_channel\"\n    return await self._webhook_client.send(\n        text=text,\n        attachments=attachments,\n        blocks=blocks,\n        response_type=response_type,\n        replace_original=replace_original,\n        delete_original=delete_original,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/#machine.plugins.block_action.BlockAction.send_dm","title":"<code>send_dm(text: str | None = None, attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None, blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None, **kwargs: Any) -&gt; AsyncSlackResponse</code>  <code>async</code>","text":"<p>Send a DM to the user that triggered the block action</p> <p>Send a Direct Message to the user that triggered the block action by opening a DM channel and sending a message to it. Allows for rich formatting using blocks and/or attachments. You can provide blocks and attachments as Python dicts or you can use the convenience classes that the underlying slack client provides. Any extra kwargs you provide, will be passed on directly to the <code>chat.postMessage</code> request.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str | None</code> <p>message text</p> <code>None</code> <code>attachments</code> <code>Sequence[Attachment] | Sequence[dict[str, Any]] | None</code> <p>optional attachments (see attachments)</p> <code>None</code> <code>blocks</code> <code>Sequence[Block] | Sequence[dict[str, Any]] | None</code> <p>optional blocks (see blocks)</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncSlackResponse</code> <p>Dictionary deserialized from chat.postMessage response.</p> Source code in <code>src/machine/plugins/block_action.py</code> <pre><code>async def send_dm(\n    self,\n    text: str | None = None,\n    attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None,\n    blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None,\n    **kwargs: Any,\n) -&gt; AsyncSlackResponse:\n    \"\"\"Send a DM to the user that triggered the block action\n\n    Send a Direct Message to the user that triggered the block action by opening a DM channel and\n    sending a message to it.\n    Allows for rich formatting using [blocks] and/or [attachments]. You can provide blocks\n    and attachments as Python dicts or you can use the [convenience classes] that the\n    underlying slack client provides.\n    Any extra kwargs you provide, will be passed on directly to the `chat.postMessage` request.\n\n    [attachments]: https://api.slack.com/docs/message-attachments\n    [blocks]: https://api.slack.com/reference/block-kit/blocks\n    [convenience classes]: https://github.com/slackapi/python-slack-sdk/tree/main/slack/web/classes\n\n    Args:\n        text: message text\n        attachments: optional attachments (see [attachments](https://api.slack.com/docs/message-attachments))\n        blocks: optional blocks (see [blocks](https://api.slack.com/reference/block-kit/blocks))\n\n    Returns:\n        Dictionary deserialized from [chat.postMessage](https://api.slack.com/methods/chat.postMessage) response.\n    \"\"\"\n    return await self._client.send_dm(self.user.id, text, attachments=attachments, blocks=blocks, **kwargs)\n</code></pre>"},{"location":"api/#machine.plugins.block_action.BlockAction.open_modal","title":"<code>open_modal(view: dict | View, **kwargs: Any) -&gt; AsyncSlackResponse</code>  <code>async</code>","text":"<p>Open a modal in response to the block action</p> <p>Open a modal in response to the block action, using the trigger_id that was returned when the block action was triggered. Any extra kwargs you provide, will be passed on directly to views.open</p> Note <p>You have to call this method within 3 seconds of receiving the block action payload.</p> <p>Parameters:</p> Name Type Description Default <code>view</code> <code>dict | View</code> <p>the view to open</p> required <p>Returns:</p> Type Description <code>AsyncSlackResponse</code> <p>Dictionary deserialized from views.open</p> Source code in <code>src/machine/plugins/block_action.py</code> <pre><code>async def open_modal(\n    self,\n    view: dict | View,\n    **kwargs: Any,\n) -&gt; AsyncSlackResponse:\n    \"\"\"Open a modal in response to the block action\n\n    Open a modal in response to the block action, using the trigger_id that was returned when the block action was\n    triggered.\n    Any extra kwargs you provide, will be passed on directly to\n    [views.open](https://api.slack.com/methods/views.open)\n\n    Note:\n        You have to call this method within 3 seconds of receiving the block action payload.\n\n    Args:\n        view: the view to open\n\n    Returns:\n        Dictionary deserialized from [views.open](https://api.slack.com/methods/views.open)\n    \"\"\"\n    return await self._client.open_modal(self.trigger_id, view, **kwargs)\n</code></pre>"},{"location":"api/#machine.plugins.modals.ModalSubmission","title":"<code>machine.plugins.modals.ModalSubmission</code>","text":"<p>A Slack modal submission that was received by the bot</p> <p>This class represents a modal submission that was received by the bot and passed to a plugin.</p> <p>Attributes:</p> Name Type Description <code>payload</code> <code>ViewSubmissionPayload</code> <p>The payload that was received by the bot when the modal was submitted</p> Source code in <code>src/machine/plugins/modals.py</code> <pre><code>class ModalSubmission:\n    \"\"\"A Slack modal submission that was received by the bot\n\n    This class represents a modal submission that was received by the bot and passed to a plugin.\n\n    Attributes:\n        payload: The payload that was received by the bot when the modal was submitted\n    \"\"\"\n\n    payload: ViewSubmissionPayload\n\n    def __init__(self, client: SlackClient, payload: ViewSubmissionPayload):\n        self._client = client\n        self.payload = payload\n\n    @property\n    def user(self) -&gt; User:\n        \"\"\"The user that submitted the modal\n\n        Returns:\n            the user that submitted the modal\n        \"\"\"\n        return self._client.users[self.payload.user.id]\n\n    @property\n    def view(self) -&gt; View:\n        \"\"\"The view that was submitted including the state of all the elements in the view\n\n        Returns:\n            the view that was submitted\n        \"\"\"\n        return self.payload.view\n\n    @property\n    def trigger_id(self) -&gt; str:\n        \"\"\"The trigger id associated with the submitted modal\n\n        The trigger id can be used to open another modal\n\n        Note:\n            The trigger id is only valid for 3 seconds after the modal was submitted.\n\n            You can use [`open_modal()`][machine.plugins.modals.ModalSubmission.open_modal] to open a modal instead of\n            using the `trigger_id` directly.\n\n        Returns:\n            the trigger id for the modal\n        \"\"\"\n        return self.payload.trigger_id\n\n    async def open_modal(\n        self,\n        view: dict | SlackSDKView,\n        **kwargs: Any,\n    ) -&gt; AsyncSlackResponse:\n        \"\"\"Open another modal in response to the modal submission\n\n        Open another modal in response to modal submission, using the trigger_id that was returned when the modal was\n        submitted.\n        Any extra kwargs you provide, will be passed on directly to\n        [views.open](https://api.slack.com/methods/views.open)\n\n        Note:\n            You have to call this method within 3 seconds of receiving the modal submission payload.\n\n        Args:\n            view: the view to open\n\n        Returns:\n            Dictionary deserialized from [views.open](https://api.slack.com/methods/views.open)\n        \"\"\"\n        return await self._client.open_modal(self.trigger_id, view, **kwargs)\n\n    async def push_modal(\n        self,\n        view: dict | SlackSDKView,\n        **kwargs: Any,\n    ) -&gt; AsyncSlackResponse:\n        \"\"\"Push a new modal view in response to the modal submission\n\n        Push a new modal view on top of the view stack in response to modal submission, using the trigger_id that was\n        returned when the modal was submitted.\n        Any extra kwargs you provide, will be passed on directly to\n        [views.push](https://api.slack.com/methods/views.push)\n\n        Note:\n            You have to call this method within 3 seconds of receiving the modal submission payload.\n\n        Args:\n            view: the view to push\n\n        Returns:\n            Dictionary deserialized from [views.push](https://api.slack.com/methods/views.push)\n        \"\"\"\n        return await self._client.push_modal(self.trigger_id, view, **kwargs)\n\n    async def update_modal(\n        self,\n        view: dict | SlackSDKView,\n        **kwargs: Any,\n    ) -&gt; AsyncSlackResponse:\n        \"\"\"Update the modal view in response to the modal submission\n\n        Update the modal view in response to modal submission, using the trigger_id that was returned when the modal was\n        submitted.\n        Any extra kwargs you provide, will be passed on directly to\n        [views.update](https://api.slack.com/methods/views.update)\n\n        Note:\n            You have to call this method within 3 seconds of receiving the modal submission payload.\n\n        Args:\n            view: the view to update\n\n        Returns:\n            Dictionary deserialized from [views.update](https://api.slack.com/methods/views.update)\n        \"\"\"\n        return await self._client.update_modal(view, self.payload.view.id, self.payload.view.external_id, **kwargs)\n\n    async def send_dm(\n        self,\n        text: str | None = None,\n        attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None,\n        blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None,\n        **kwargs: Any,\n    ) -&gt; AsyncSlackResponse:\n        \"\"\"Send a DM to the user that submitted the modal\n\n        Send a Direct Message to the user that submitted the modal by opening a DM channel and\n        sending a message to it.\n        Allows for rich formatting using [blocks] and/or [attachments] . You can provide blocks\n        and attachments as Python dicts or you can use the [convenience classes] that the\n        underlying slack client provides.\n        Any extra kwargs you provide, will be passed on directly to the\n        [chat.postMessage](https://api.slack.com/methods/chat.postMessage) request.\n\n        [attachments]: https://api.slack.com/docs/message-attachments\n        [blocks]: https://api.slack.com/reference/block-kit/blocks\n        [convenience classes]: https://github.com/slackapi/python-slack-sdk/tree/main/slack/web/classes\n\n        Args:\n            text: message text\n            attachments: optional attachments (see [attachments](https://api.slack.com/docs/message-attachments))\n            blocks: optional blocks (see [blocks](https://api.slack.com/reference/block-kit/blocks))\n\n        Returns:\n            Dictionary deserialized from [chat.postMessage](https://api.slack.com/methods/chat.postMessage) response.\n        \"\"\"\n        return await self._client.send_dm(self.user.id, text, attachments=attachments, blocks=blocks, **kwargs)\n</code></pre>"},{"location":"api/#machine.plugins.modals.ModalSubmission.user","title":"<code>user: User</code>  <code>property</code>","text":"<p>The user that submitted the modal</p> <p>Returns:</p> Type Description <code>User</code> <p>the user that submitted the modal</p>"},{"location":"api/#machine.plugins.modals.ModalSubmission.view","title":"<code>view: View</code>  <code>property</code>","text":"<p>The view that was submitted including the state of all the elements in the view</p> <p>Returns:</p> Type Description <code>View</code> <p>the view that was submitted</p>"},{"location":"api/#machine.plugins.modals.ModalSubmission.trigger_id","title":"<code>trigger_id: str</code>  <code>property</code>","text":"<p>The trigger id associated with the submitted modal</p> <p>The trigger id can be used to open another modal</p> Note <p>The trigger id is only valid for 3 seconds after the modal was submitted.</p> <p>You can use <code>open_modal()</code> to open a modal instead of using the <code>trigger_id</code> directly.</p> <p>Returns:</p> Type Description <code>str</code> <p>the trigger id for the modal</p>"},{"location":"api/#machine.plugins.modals.ModalSubmission.open_modal","title":"<code>open_modal(view: dict | SlackSDKView, **kwargs: Any) -&gt; AsyncSlackResponse</code>  <code>async</code>","text":"<p>Open another modal in response to the modal submission</p> <p>Open another modal in response to modal submission, using the trigger_id that was returned when the modal was submitted. Any extra kwargs you provide, will be passed on directly to views.open</p> Note <p>You have to call this method within 3 seconds of receiving the modal submission payload.</p> <p>Parameters:</p> Name Type Description Default <code>view</code> <code>dict | View</code> <p>the view to open</p> required <p>Returns:</p> Type Description <code>AsyncSlackResponse</code> <p>Dictionary deserialized from views.open</p> Source code in <code>src/machine/plugins/modals.py</code> <pre><code>async def open_modal(\n    self,\n    view: dict | SlackSDKView,\n    **kwargs: Any,\n) -&gt; AsyncSlackResponse:\n    \"\"\"Open another modal in response to the modal submission\n\n    Open another modal in response to modal submission, using the trigger_id that was returned when the modal was\n    submitted.\n    Any extra kwargs you provide, will be passed on directly to\n    [views.open](https://api.slack.com/methods/views.open)\n\n    Note:\n        You have to call this method within 3 seconds of receiving the modal submission payload.\n\n    Args:\n        view: the view to open\n\n    Returns:\n        Dictionary deserialized from [views.open](https://api.slack.com/methods/views.open)\n    \"\"\"\n    return await self._client.open_modal(self.trigger_id, view, **kwargs)\n</code></pre>"},{"location":"api/#machine.plugins.modals.ModalSubmission.push_modal","title":"<code>push_modal(view: dict | SlackSDKView, **kwargs: Any) -&gt; AsyncSlackResponse</code>  <code>async</code>","text":"<p>Push a new modal view in response to the modal submission</p> <p>Push a new modal view on top of the view stack in response to modal submission, using the trigger_id that was returned when the modal was submitted. Any extra kwargs you provide, will be passed on directly to views.push</p> Note <p>You have to call this method within 3 seconds of receiving the modal submission payload.</p> <p>Parameters:</p> Name Type Description Default <code>view</code> <code>dict | View</code> <p>the view to push</p> required <p>Returns:</p> Type Description <code>AsyncSlackResponse</code> <p>Dictionary deserialized from views.push</p> Source code in <code>src/machine/plugins/modals.py</code> <pre><code>async def push_modal(\n    self,\n    view: dict | SlackSDKView,\n    **kwargs: Any,\n) -&gt; AsyncSlackResponse:\n    \"\"\"Push a new modal view in response to the modal submission\n\n    Push a new modal view on top of the view stack in response to modal submission, using the trigger_id that was\n    returned when the modal was submitted.\n    Any extra kwargs you provide, will be passed on directly to\n    [views.push](https://api.slack.com/methods/views.push)\n\n    Note:\n        You have to call this method within 3 seconds of receiving the modal submission payload.\n\n    Args:\n        view: the view to push\n\n    Returns:\n        Dictionary deserialized from [views.push](https://api.slack.com/methods/views.push)\n    \"\"\"\n    return await self._client.push_modal(self.trigger_id, view, **kwargs)\n</code></pre>"},{"location":"api/#machine.plugins.modals.ModalSubmission.update_modal","title":"<code>update_modal(view: dict | SlackSDKView, **kwargs: Any) -&gt; AsyncSlackResponse</code>  <code>async</code>","text":"<p>Update the modal view in response to the modal submission</p> <p>Update the modal view in response to modal submission, using the trigger_id that was returned when the modal was submitted. Any extra kwargs you provide, will be passed on directly to views.update</p> Note <p>You have to call this method within 3 seconds of receiving the modal submission payload.</p> <p>Parameters:</p> Name Type Description Default <code>view</code> <code>dict | View</code> <p>the view to update</p> required <p>Returns:</p> Type Description <code>AsyncSlackResponse</code> <p>Dictionary deserialized from views.update</p> Source code in <code>src/machine/plugins/modals.py</code> <pre><code>async def update_modal(\n    self,\n    view: dict | SlackSDKView,\n    **kwargs: Any,\n) -&gt; AsyncSlackResponse:\n    \"\"\"Update the modal view in response to the modal submission\n\n    Update the modal view in response to modal submission, using the trigger_id that was returned when the modal was\n    submitted.\n    Any extra kwargs you provide, will be passed on directly to\n    [views.update](https://api.slack.com/methods/views.update)\n\n    Note:\n        You have to call this method within 3 seconds of receiving the modal submission payload.\n\n    Args:\n        view: the view to update\n\n    Returns:\n        Dictionary deserialized from [views.update](https://api.slack.com/methods/views.update)\n    \"\"\"\n    return await self._client.update_modal(view, self.payload.view.id, self.payload.view.external_id, **kwargs)\n</code></pre>"},{"location":"api/#machine.plugins.modals.ModalSubmission.send_dm","title":"<code>send_dm(text: str | None = None, attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None, blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None, **kwargs: Any) -&gt; AsyncSlackResponse</code>  <code>async</code>","text":"<p>Send a DM to the user that submitted the modal</p> <p>Send a Direct Message to the user that submitted the modal by opening a DM channel and sending a message to it. Allows for rich formatting using blocks and/or attachments . You can provide blocks and attachments as Python dicts or you can use the convenience classes that the underlying slack client provides. Any extra kwargs you provide, will be passed on directly to the chat.postMessage request.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str | None</code> <p>message text</p> <code>None</code> <code>attachments</code> <code>Sequence[Attachment] | Sequence[dict[str, Any]] | None</code> <p>optional attachments (see attachments)</p> <code>None</code> <code>blocks</code> <code>Sequence[Block] | Sequence[dict[str, Any]] | None</code> <p>optional blocks (see blocks)</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncSlackResponse</code> <p>Dictionary deserialized from chat.postMessage response.</p> Source code in <code>src/machine/plugins/modals.py</code> <pre><code>async def send_dm(\n    self,\n    text: str | None = None,\n    attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None,\n    blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None,\n    **kwargs: Any,\n) -&gt; AsyncSlackResponse:\n    \"\"\"Send a DM to the user that submitted the modal\n\n    Send a Direct Message to the user that submitted the modal by opening a DM channel and\n    sending a message to it.\n    Allows for rich formatting using [blocks] and/or [attachments] . You can provide blocks\n    and attachments as Python dicts or you can use the [convenience classes] that the\n    underlying slack client provides.\n    Any extra kwargs you provide, will be passed on directly to the\n    [chat.postMessage](https://api.slack.com/methods/chat.postMessage) request.\n\n    [attachments]: https://api.slack.com/docs/message-attachments\n    [blocks]: https://api.slack.com/reference/block-kit/blocks\n    [convenience classes]: https://github.com/slackapi/python-slack-sdk/tree/main/slack/web/classes\n\n    Args:\n        text: message text\n        attachments: optional attachments (see [attachments](https://api.slack.com/docs/message-attachments))\n        blocks: optional blocks (see [blocks](https://api.slack.com/reference/block-kit/blocks))\n\n    Returns:\n        Dictionary deserialized from [chat.postMessage](https://api.slack.com/methods/chat.postMessage) response.\n    \"\"\"\n    return await self._client.send_dm(self.user.id, text, attachments=attachments, blocks=blocks, **kwargs)\n</code></pre>"},{"location":"api/#machine.plugins.modals.ModalClosure","title":"<code>machine.plugins.modals.ModalClosure</code>","text":"<p>A Slack modal closure that was received by the bot</p> <p>This class represents the closure (cancellation) of a modal that was received by the bot and passed to a plugin.</p> <p>Attributes:</p> Name Type Description <code>payload</code> <code>ViewClosedPayload</code> <p>The payload that was received by the bot when the modal was closed</p> Source code in <code>src/machine/plugins/modals.py</code> <pre><code>class ModalClosure:\n    \"\"\"A Slack modal closure that was received by the bot\n\n    This class represents the closure (cancellation) of a modal that was received by the bot and passed to a plugin.\n\n    Attributes:\n        payload: The payload that was received by the bot when the modal was closed\n    \"\"\"\n\n    payload: ViewClosedPayload\n\n    def __init__(self, client: SlackClient, payload: ViewClosedPayload):\n        self._client = client\n        self.payload = payload\n\n    @property\n    def user(self) -&gt; User:\n        \"\"\"The user that closed the modal\n\n        Returns:\n            the user that closed the modal\n        \"\"\"\n        return self._client.users[self.payload.user.id]\n\n    @property\n    def view(self) -&gt; View:\n        \"\"\"The view that was closed including the state of all the elements in the view when it was closed\n\n        Returns:\n            the view that was closed\n        \"\"\"\n        return self.payload.view\n\n    async def send_dm(\n        self,\n        text: str | None = None,\n        attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None,\n        blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None,\n        **kwargs: Any,\n    ) -&gt; AsyncSlackResponse:\n        \"\"\"Send a DM to the user that closed the modal\n\n        Send a Direct Message to the user that closed the modal by opening a DM channel and\n        sending a message to it.\n        Allows for rich formatting using [blocks] and/or [attachments] . You can provide blocks\n        and attachments as Python dicts or you can use the [convenience classes] that the\n        underlying slack client provides.\n        Any extra kwargs you provide, will be passed on directly to the\n        [chat.postMessage](https://api.slack.com/methods/chat.postMessage) request.\n\n        [attachments]: https://api.slack.com/docs/message-attachments\n        [blocks]: https://api.slack.com/reference/block-kit/blocks\n        [convenience classes]: https://github.com/slackapi/python-slack-sdk/tree/main/slack/web/classes\n\n        Args:\n            text: message text\n            attachments: optional attachments (see [attachments](https://api.slack.com/docs/message-attachments))\n            blocks: optional blocks (see [blocks](https://api.slack.com/reference/block-kit/blocks))\n        Returns:\n            Dictionary deserialized from [chat.postMessage](https://api.slack.com/methods/chat.postMessage) response.\n        \"\"\"\n        return await self._client.send_dm(self.user.id, text, attachments=attachments, blocks=blocks, **kwargs)\n</code></pre>"},{"location":"api/#machine.plugins.modals.ModalClosure.user","title":"<code>user: User</code>  <code>property</code>","text":"<p>The user that closed the modal</p> <p>Returns:</p> Type Description <code>User</code> <p>the user that closed the modal</p>"},{"location":"api/#machine.plugins.modals.ModalClosure.view","title":"<code>view: View</code>  <code>property</code>","text":"<p>The view that was closed including the state of all the elements in the view when it was closed</p> <p>Returns:</p> Type Description <code>View</code> <p>the view that was closed</p>"},{"location":"api/#machine.plugins.modals.ModalClosure.send_dm","title":"<code>send_dm(text: str | None = None, attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None, blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None, **kwargs: Any) -&gt; AsyncSlackResponse</code>  <code>async</code>","text":"<p>Send a DM to the user that closed the modal</p> <p>Send a Direct Message to the user that closed the modal by opening a DM channel and sending a message to it. Allows for rich formatting using blocks and/or attachments . You can provide blocks and attachments as Python dicts or you can use the convenience classes that the underlying slack client provides. Any extra kwargs you provide, will be passed on directly to the chat.postMessage request.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str | None</code> <p>message text</p> <code>None</code> <code>attachments</code> <code>Sequence[Attachment] | Sequence[dict[str, Any]] | None</code> <p>optional attachments (see attachments)</p> <code>None</code> <code>blocks</code> <code>Sequence[Block] | Sequence[dict[str, Any]] | None</code> <p>optional blocks (see blocks)</p> <code>None</code> <p>Returns:     Dictionary deserialized from chat.postMessage response.</p> Source code in <code>src/machine/plugins/modals.py</code> <pre><code>async def send_dm(\n    self,\n    text: str | None = None,\n    attachments: Sequence[Attachment] | Sequence[dict[str, Any]] | None = None,\n    blocks: Sequence[Block] | Sequence[dict[str, Any]] | None = None,\n    **kwargs: Any,\n) -&gt; AsyncSlackResponse:\n    \"\"\"Send a DM to the user that closed the modal\n\n    Send a Direct Message to the user that closed the modal by opening a DM channel and\n    sending a message to it.\n    Allows for rich formatting using [blocks] and/or [attachments] . You can provide blocks\n    and attachments as Python dicts or you can use the [convenience classes] that the\n    underlying slack client provides.\n    Any extra kwargs you provide, will be passed on directly to the\n    [chat.postMessage](https://api.slack.com/methods/chat.postMessage) request.\n\n    [attachments]: https://api.slack.com/docs/message-attachments\n    [blocks]: https://api.slack.com/reference/block-kit/blocks\n    [convenience classes]: https://github.com/slackapi/python-slack-sdk/tree/main/slack/web/classes\n\n    Args:\n        text: message text\n        attachments: optional attachments (see [attachments](https://api.slack.com/docs/message-attachments))\n        blocks: optional blocks (see [blocks](https://api.slack.com/reference/block-kit/blocks))\n    Returns:\n        Dictionary deserialized from [chat.postMessage](https://api.slack.com/methods/chat.postMessage) response.\n    \"\"\"\n    return await self._client.send_dm(self.user.id, text, attachments=attachments, blocks=blocks, **kwargs)\n</code></pre>"},{"location":"api/#decorators","title":"Decorators","text":"<p>These are the decorators you can use to have Slack Machine respond to specific things (events, messages, etc.)</p>"},{"location":"api/#machine.plugins.decorators","title":"<code>machine.plugins.decorators</code>","text":""},{"location":"api/#machine.plugins.decorators.process","title":"<code>process(slack_event_type: str) -&gt; Callable[[Callable[P, R]], DecoratedPluginFunc[P, R]]</code>","text":"<p>Process Slack events of a specific type</p> <p>This decorator will enable a Plugin method to process Slack events of a specific type. The Plugin method will be called for each event of the specified type that the bot receives. The received event will be passed to the method when called.</p> <p>Parameters:</p> Name Type Description Default <code>slack_event_type</code> <code>str</code> <p>type of event the method needs to process. Can be any event supported by the Events API</p> required <p>Returns:</p> Type Description <code>Callable[[Callable[P, R]], DecoratedPluginFunc[P, R]]</code> <p>wrapped method</p> Source code in <code>src/machine/plugins/decorators.py</code> <pre><code>def process(slack_event_type: str) -&gt; Callable[[Callable[P, R]], DecoratedPluginFunc[P, R]]:\n    \"\"\"Process Slack events of a specific type\n\n    This decorator will enable a Plugin method to process [Slack events] of a specific type. The\n    Plugin method will be called for each event of the specified type that the bot receives.\n    The received event will be passed to the method when called.\n\n    [Slack events]: https://api.slack.com/events\n\n    Args:\n        slack_event_type: type of event the method needs to process. Can be any event supported\n            by the [Events API](https://api.slack.com/events?filter=Events)\n\n    Returns:\n        wrapped method\n    \"\"\"\n\n    def process_decorator(f: Callable[P, R]) -&gt; DecoratedPluginFunc[P, R]:\n        fn = cast(DecoratedPluginFunc, f)\n        fn.metadata = getattr(f, \"metadata\", Metadata())\n        fn.metadata.plugin_actions.process.append(slack_event_type)\n        return fn\n\n    return process_decorator\n</code></pre>"},{"location":"api/#machine.plugins.decorators.listen_to","title":"<code>listen_to(regex: str, flags: re.RegexFlag | int = re.IGNORECASE, handle_message_changed: bool = False) -&gt; Callable[[Callable[P, R]], DecoratedPluginFunc[P, R]]</code>","text":"<p>Listen to messages matching a regex pattern</p> <p>This decorator will enable a Plugin method to listen to messages that match a regex pattern. The Plugin method will be called for each message that matches the specified regex pattern. The received <code>Message</code> will be passed to the method when called. Named groups can be used in the regex pattern, to catch specific parts of the message. These groups will be passed to the method as keyword arguments when called.</p> <p>Parameters:</p> Name Type Description Default <code>regex</code> <code>str</code> <p>regex pattern to listen for</p> required <code>flags</code> <code>RegexFlag | int</code> <p>regex flags to apply when matching</p> <code>IGNORECASE</code> <code>handle_message_changed</code> <code>bool</code> <p>if changed messages should trigger the decorated function</p> <code>False</code> <p>Returns:</p> Type Description <code>Callable[[Callable[P, R]], DecoratedPluginFunc[P, R]]</code> <p>wrapped method</p> Source code in <code>src/machine/plugins/decorators.py</code> <pre><code>def listen_to(\n    regex: str, flags: re.RegexFlag | int = re.IGNORECASE, handle_message_changed: bool = False\n) -&gt; Callable[[Callable[P, R]], DecoratedPluginFunc[P, R]]:\n    \"\"\"Listen to messages matching a regex pattern\n\n    This decorator will enable a Plugin method to listen to messages that match a regex pattern.\n    The Plugin method will be called for each message that matches the specified regex pattern.\n    The received [`Message`][machine.plugins.message.Message] will be passed to the method when called.\n    Named groups can be used in the regex pattern, to catch specific parts of the message. These\n    groups will be passed to the method as keyword arguments when called.\n\n    Args:\n        regex: regex pattern to listen for\n        flags: regex flags to apply when matching\n        handle_message_changed: if changed messages should trigger the decorated function\n\n    Returns:\n        wrapped method\n    \"\"\"\n\n    def listen_to_decorator(f: Callable[P, R]) -&gt; DecoratedPluginFunc[P, R]:\n        fn = cast(DecoratedPluginFunc, f)\n        fn.metadata = getattr(f, \"metadata\", Metadata())\n        fn.metadata.plugin_actions.listen_to.append(MatcherConfig(re.compile(regex, flags), handle_message_changed))\n        return fn\n\n    return listen_to_decorator\n</code></pre>"},{"location":"api/#machine.plugins.decorators.respond_to","title":"<code>respond_to(regex: str, flags: re.RegexFlag | int = re.IGNORECASE, handle_message_changed: bool = False) -&gt; Callable[[Callable[P, R]], DecoratedPluginFunc[P, R]]</code>","text":"<p>Listen to messages mentioning the bot and matching a regex pattern</p> <p>This decorator will enable a Plugin method to listen to messages that are directed to the bot (ie. message starts by mentioning the bot) and match a regex pattern. The Plugin method will be called for each message that mentions the bot and matches the specified regex pattern. The received <code>Message</code> will be passed to the method when called. Named groups can be used in the regex pattern, to catch specific parts of the message. These groups will be passed to the method as keyword arguments when called.</p> <p>Parameters:</p> Name Type Description Default <code>regex</code> <code>str</code> <p>regex pattern to listen for</p> required <code>flags</code> <code>RegexFlag | int</code> <p>regex flags to apply when matching</p> <code>IGNORECASE</code> <code>handle_message_changed</code> <code>bool</code> <p>if changed messages should trigger the decorated function</p> <code>False</code> <p>Returns:</p> Type Description <code>Callable[[Callable[P, R]], DecoratedPluginFunc[P, R]]</code> <p>wrapped method</p> Source code in <code>src/machine/plugins/decorators.py</code> <pre><code>def respond_to(\n    regex: str, flags: re.RegexFlag | int = re.IGNORECASE, handle_message_changed: bool = False\n) -&gt; Callable[[Callable[P, R]], DecoratedPluginFunc[P, R]]:\n    \"\"\"Listen to messages mentioning the bot and matching a regex pattern\n\n    This decorator will enable a Plugin method to listen to messages that are directed to the bot\n    (ie. message starts by mentioning the bot) and match a regex pattern.\n    The Plugin method will be called for each message that mentions the bot and matches the\n    specified regex pattern. The received [`Message`][machine.plugins.message.Message] will be passed\n    to the method when called. Named groups can be used in the regex pattern, to catch specific\n    parts of the message. These groups will be passed to the method as keyword arguments when\n    called.\n\n    Args:\n        regex: regex pattern to listen for\n        flags: regex flags to apply when matching\n        handle_message_changed: if changed messages should trigger the decorated function\n\n    Returns:\n        wrapped method\n    \"\"\"\n\n    def respond_to_decorator(f: Callable[P, R]) -&gt; DecoratedPluginFunc[P, R]:\n        fn = cast(DecoratedPluginFunc, f)\n        fn.metadata = getattr(f, \"metadata\", Metadata())\n        fn.metadata.plugin_actions.respond_to.append(MatcherConfig(re.compile(regex, flags), handle_message_changed))\n        return fn\n\n    return respond_to_decorator\n</code></pre>"},{"location":"api/#machine.plugins.decorators.command","title":"<code>command(slash_command: str) -&gt; Callable[[Callable[P, R]], DecoratedPluginFunc[P, R]]</code>","text":"<p>Respond to a slash command</p> <p>This decorator will enable a Plugin method to respond to slash commands</p> <p>Parameters:</p> Name Type Description Default <code>slash_command</code> <code>str</code> <p>the slash command to respond to</p> required <p>Returns:</p> Type Description <code>Callable[[Callable[P, R]], DecoratedPluginFunc[P, R]]</code> <p>wrapped method</p> Source code in <code>src/machine/plugins/decorators.py</code> <pre><code>def command(slash_command: str) -&gt; Callable[[Callable[P, R]], DecoratedPluginFunc[P, R]]:\n    \"\"\"Respond to a slash command\n\n    This decorator will enable a Plugin method to respond to slash commands\n\n    Args:\n        slash_command: the slash command to respond to\n\n    Returns:\n        wrapped method\n    \"\"\"\n\n    def command_decorator(f: Callable[P, R]) -&gt; DecoratedPluginFunc[P, R]:\n        fn = cast(DecoratedPluginFunc, f)\n        fn.metadata = getattr(f, \"metadata\", Metadata())\n        normalized_slash_command = f\"/{slash_command}\" if not slash_command.startswith(\"/\") else slash_command\n        fn.metadata.plugin_actions.commands.append(\n            CommandConfig(command=normalized_slash_command, is_generator=inspect.isasyncgenfunction(f))\n        )\n        return fn\n\n    return command_decorator\n</code></pre>"},{"location":"api/#machine.plugins.decorators.action","title":"<code>action(action_id: Union[re.Pattern[str], str, None] = None, block_id: Union[re.Pattern[str], str, None] = None) -&gt; Callable[[Callable[P, R]], DecoratedPluginFunc[P, R]]</code>","text":"<p>Respond to block actions</p> <p>This decorator will enable a Plugin method to be triggered when certain block actions are received. The Plugin method will be called when a block action event is received for which the <code>action_id</code> and <code>block_id</code> match the provided values. <code>action_id</code> and <code>block_id</code> can be strings, in which case the incoming action_id and block_id must match exactly, or regex patterns, in which case the incoming action_id and block_id must match the regex pattern.</p> <p>Both action_id and block_id are optional, but at least one of them must be provided.</p> <p>Parameters:</p> Name Type Description Default <code>action_id</code> <code>Union[Pattern[str], str, None]</code> <p>the action_id to respond to, can be a string or regex pattern</p> <code>None</code> <code>block_id</code> <code>Union[Pattern[str], str, None]</code> <p>the block_id to respond to, can be a string or regex pattern</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[[Callable[P, R]], DecoratedPluginFunc[P, R]]</code> <p>wrapped method</p> Source code in <code>src/machine/plugins/decorators.py</code> <pre><code>def action(\n    action_id: Union[re.Pattern[str], str, None] = None, block_id: Union[re.Pattern[str], str, None] = None\n) -&gt; Callable[[Callable[P, R]], DecoratedPluginFunc[P, R]]:\n    \"\"\"Respond to block actions\n\n    This decorator will enable a Plugin method to be triggered when certain block actions are\n    received. The Plugin method will be called when a block action event is received for which\n    the `action_id` and `block_id` match the provided values. `action_id` and `block_id` can be strings,\n    in which case the incoming action_id and block_id must match exactly, or regex patterns, in\n    which case the incoming action_id and block_id must match the regex pattern.\n\n    Both action_id and block_id are optional, but **at least one of them must be provided**.\n\n    Args:\n        action_id: the action_id to respond to, can be a string or regex pattern\n        block_id: the block_id to respond to, can be a string or regex pattern\n\n    Returns:\n        wrapped method\n    \"\"\"\n\n    def action_decorator(f: Callable[P, R]) -&gt; DecoratedPluginFunc[P, R]:\n        fn = cast(DecoratedPluginFunc, f)\n        fn.metadata = getattr(f, \"metadata\", Metadata())\n        if action_id is None and block_id is None:\n            raise ValueError(\"At least one of action_id or block_id must be provided\")\n        fn.metadata.plugin_actions.actions.append(ActionConfig(action_id=action_id, block_id=block_id))\n        return fn\n\n    return action_decorator\n</code></pre>"},{"location":"api/#machine.plugins.decorators.modal","title":"<code>modal(callback_id: Union[re.Pattern[str], str]) -&gt; Callable[[Callable[P, R]], DecoratedPluginFunc[P, R]]</code>","text":"<p>Respond to modal submissions</p> <p>This decorator will enable a Plugin method to be triggered when certain modals are submitted. The Plugin method will be called when a modal submission event is received for which the <code>callback_id</code> matches the provided value. The <code>callback_id</code> can be a string or a regex pattern.</p> <p>Parameters:</p> Name Type Description Default <code>callback_id</code> <code>Union[Pattern[str], str]</code> <p>the callback id to respond to, can be a string or regex pattern</p> required <p>Returns:</p> Type Description <code>Callable[[Callable[P, R]], DecoratedPluginFunc[P, R]]</code> <p>wrapped method</p> Source code in <code>src/machine/plugins/decorators.py</code> <pre><code>def modal(callback_id: Union[re.Pattern[str], str]) -&gt; Callable[[Callable[P, R]], DecoratedPluginFunc[P, R]]:\n    \"\"\"Respond to modal submissions\n\n    This decorator will enable a Plugin method to be triggered when certain modals are submitted.\n    The Plugin method will be called when a modal submission event is received for which the\n    `callback_id` matches the provided value. The `callback_id` can be a string or a regex pattern.\n\n    Args:\n        callback_id: the callback id to respond to, can be a string or regex pattern\n\n    Returns:\n        wrapped method\n    \"\"\"\n\n    def modal_decorator(f: Callable[P, R]) -&gt; DecoratedPluginFunc[P, R]:\n        fn = cast(DecoratedPluginFunc, f)\n        fn.metadata = getattr(f, \"metadata\", Metadata())\n        is_generator = inspect.isasyncgenfunction(f)\n        fn.metadata.plugin_actions.modal_submissions.append(\n            ModalConfig(callback_id=callback_id, is_generator=is_generator)\n        )\n        return fn\n\n    return modal_decorator\n</code></pre>"},{"location":"api/#machine.plugins.decorators.modal_closed","title":"<code>modal_closed(callback_id: Union[re.Pattern[str], str]) -&gt; Callable[[Callable[P, R]], DecoratedPluginFunc[P, R]]</code>","text":"<p>Respond to modal closures</p> <p>This decorator will enable a Plugin method to be triggered when certain modals are closed. The Plugin method will be called when a modal closure event is received for which the <code>callback_id</code> matches the provided value. The <code>callback_id</code> can be a string or a regex pattern.</p> Note <p>In order to receive modal close events, the modal must have the <code>notify_on_close</code> property set to <code>True</code>.</p> <p>Parameters:</p> Name Type Description Default <code>callback_id</code> <code>Union[Pattern[str], str]</code> <p>the callback id to respond to, can be a string or regex pattern</p> required <p>Returns:</p> Type Description <code>Callable[[Callable[P, R]], DecoratedPluginFunc[P, R]]</code> <p>wrapped method</p> Source code in <code>src/machine/plugins/decorators.py</code> <pre><code>def modal_closed(callback_id: Union[re.Pattern[str], str]) -&gt; Callable[[Callable[P, R]], DecoratedPluginFunc[P, R]]:\n    \"\"\"Respond to modal closures\n\n    This decorator will enable a Plugin method to be triggered when certain modals are closed.\n    The Plugin method will be called when a modal closure event is received for which the\n    `callback_id` matches the provided value. The `callback_id` can be a string or a regex pattern.\n\n    Note:\n        In order to receive modal close events, the modal must have the `notify_on_close` property set to `True`.\n\n    Args:\n        callback_id: the callback id to respond to, can be a string or regex pattern\n\n    Returns:\n        wrapped method\n    \"\"\"\n\n    def modal_closed_decorator(f: Callable[P, R]) -&gt; DecoratedPluginFunc[P, R]:\n        fn = cast(DecoratedPluginFunc, f)\n        fn.metadata = getattr(f, \"metadata\", Metadata())\n        is_generator = inspect.isasyncgenfunction(f)\n        if is_generator:\n            raise ValueError(\"Modal closed handlers cannot be async generators\")\n        fn.metadata.plugin_actions.modal_closures.append(ModalConfig(callback_id=callback_id))\n        return fn\n\n    return modal_closed_decorator\n</code></pre>"},{"location":"api/#machine.plugins.decorators.schedule","title":"<code>schedule(year: int | str | None = None, month: int | str | None = None, day: int | str | None = None, week: int | str | None = None, day_of_week: int | str | None = None, hour: int | str | None = None, minute: int | str | None = None, second: int | str | None = None, start_date: datetime | str | None = None, end_date: datetime | str | None = None, timezone: tzinfo | str | None = None) -&gt; Callable[[Callable[P, R]], DecoratedPluginFunc[P, R]]</code>","text":"<p>Schedule a function to be executed according to a crontab-like schedule</p> <p>The decorated function will be executed according to the schedule provided. Slack Machine uses APScheduler under the hood for scheduling. For more information on the interpretation of the provided parameters, see <code>CronTrigger</code></p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int | str | None</code> <p>4-digit year</p> <code>None</code> <code>month</code> <code>int | str | None</code> <p>month (1-12)</p> <code>None</code> <code>day</code> <code>int | str | None</code> <p>day of the (1-31)</p> <code>None</code> <code>week</code> <code>int | str | None</code> <p>ISO week (1-53)</p> <code>None</code> <code>day_of_week</code> <code>int | str | None</code> <p>number or name of weekday (0-6 or mon,tue,wed,thu,fri,sat,sun)</p> <code>None</code> <code>hour</code> <code>int | str | None</code> <p>hour (0-23)</p> <code>None</code> <code>minute</code> <code>int | str | None</code> <p>minute (0-59)</p> <code>None</code> <code>second</code> <code>int | str | None</code> <p>second (0-59)</p> <code>None</code> <code>start_date</code> <code>datetime | str | None</code> <p>earliest possible date/time to trigger on (inclusive)</p> <code>None</code> <code>end_date</code> <code>datetime | str | None</code> <p>latest possible date/time to trigger on (inclusive)</p> <code>None</code> <code>timezone</code> <code>tzinfo | str | None</code> <p>time zone to use for the date/time calculations (defaults to scheduler timezone)</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[[Callable[P, R]], DecoratedPluginFunc[P, R]]</code> <p>wrapped method</p> Source code in <code>src/machine/plugins/decorators.py</code> <pre><code>def schedule(\n    year: int | str | None = None,\n    month: int | str | None = None,\n    day: int | str | None = None,\n    week: int | str | None = None,\n    day_of_week: int | str | None = None,\n    hour: int | str | None = None,\n    minute: int | str | None = None,\n    second: int | str | None = None,\n    start_date: datetime | str | None = None,\n    end_date: datetime | str | None = None,\n    timezone: tzinfo | str | None = None,\n) -&gt; Callable[[Callable[P, R]], DecoratedPluginFunc[P, R]]:\n    \"\"\"Schedule a function to be executed according to a crontab-like schedule\n\n    The decorated function will be executed according to the schedule provided. Slack Machine uses\n    APScheduler under the hood for scheduling. For more information on the interpretation of the\n    provided parameters, see [`CronTrigger`][apscheduler.triggers.cron.CronTrigger]\n\n    Args:\n        year: 4-digit year\n        month: month (1-12)\n        day: day of the (1-31)\n        week: ISO week (1-53)\n        day_of_week: number or name of weekday (0-6 or mon,tue,wed,thu,fri,sat,sun)\n        hour: hour (0-23)\n        minute: minute (0-59)\n        second: second (0-59)\n        start_date: earliest possible date/time to trigger on (inclusive)\n        end_date: latest possible date/time to trigger on (inclusive)\n        timezone: time zone to use for the date/time calculations (defaults to scheduler timezone)\n\n    Returns:\n        wrapped method\n    \"\"\"\n    kwargs = locals()\n\n    def schedule_decorator(f: Callable[P, R]) -&gt; DecoratedPluginFunc[P, R]:\n        fn = cast(DecoratedPluginFunc, f)\n        fn.metadata = getattr(f, \"metadata\", Metadata())\n        fn.metadata.plugin_actions.schedule = kwargs\n        return fn\n\n    return schedule_decorator\n</code></pre>"},{"location":"api/#machine.plugins.decorators.on","title":"<code>on(event: str) -&gt; Callable[[Callable[P, R]], Callable[P, R]]</code>","text":"<p>Listen for an event</p> <p>The decorated function will be called whenever a plugin (or Slack Machine itself) emits an event with the given name.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>str</code> <p>name of the event to listen for. Event names are global</p> required <p>Returns:</p> Type Description <code>Callable[[Callable[P, R]], Callable[P, R]]</code> <p>wrapped method</p> Source code in <code>src/machine/plugins/decorators.py</code> <pre><code>def on(event: str) -&gt; Callable[[Callable[P, R]], Callable[P, R]]:\n    \"\"\"Listen for an event\n\n    The decorated function will be called whenever a plugin (or Slack Machine itself) emits an\n    event with the given name.\n\n    Args:\n        event: name of the event to listen for. Event names are global\n\n    Returns:\n        wrapped method\n    \"\"\"\n\n    def on_decorator(f: Callable[P, R]) -&gt; Callable[P, R]:\n        ee.add_listener(event, f)\n        return f\n\n    return on_decorator\n</code></pre>"},{"location":"api/#machine.plugins.decorators.required_settings","title":"<code>required_settings(settings: list[str] | str) -&gt; Callable[[Callable[P, R]], DecoratedPluginFunc[P, R]]</code>","text":"<p>Specify a required setting for a plugin or plugin method</p> <p>The settings specified with this decorator will be added to the required settings for the plugin. If one or more settings have not been defined by the user, the plugin will not be loaded and a warning will be written to the console upon startup.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>list[str] | str</code> <p>settings that are required (can be list of strings, or single string)</p> required <p>Returns:</p> Type Description <code>Callable[[Callable[P, R]], DecoratedPluginFunc[P, R]]</code> <p>wrapped method</p> Source code in <code>src/machine/plugins/decorators.py</code> <pre><code>def required_settings(settings: list[str] | str) -&gt; Callable[[Callable[P, R]], DecoratedPluginFunc[P, R]]:\n    \"\"\"Specify a required setting for a plugin or plugin method\n\n    The settings specified with this decorator will be added to the required settings for the\n    plugin. If one or more settings have not been defined by the user, the plugin will not be\n    loaded and a warning will be written to the console upon startup.\n\n    Args:\n        settings: settings that are required (can be list of strings, or single string)\n\n    Returns:\n        wrapped method\n    \"\"\"\n\n    def required_settings_decorator(f_or_cls: Callable[P, R]) -&gt; DecoratedPluginFunc[P, R]:\n        casted_f_or_cls = cast(DecoratedPluginFunc, f_or_cls)\n        casted_f_or_cls.metadata = getattr(f_or_cls, \"metadata\", Metadata())\n        if isinstance(settings, list):\n            casted_f_or_cls.metadata.required_settings.extend(settings)\n        elif isinstance(settings, str):\n            casted_f_or_cls.metadata.required_settings.append(settings)\n        return casted_f_or_cls\n\n    return required_settings_decorator\n</code></pre>"},{"location":"api/#machine.plugins.decorators.require_any_role","title":"<code>require_any_role(required_roles: list[str]) -&gt; Callable[[Callable[..., Awaitable[None]]], Callable[..., Awaitable[None]]]</code>","text":"<p>Specify required roles for a plugin method</p> <p>To use the plugin method where this decorator is applied, the user must have at least one of the listed roles.</p> <p>Parameters:</p> Name Type Description Default <code>required_roles</code> <code>list[str]</code> <p>list of roles required to use the plugin method</p> required <p>Returns:</p> Type Description <code>Callable[[Callable[..., Awaitable[None]]], Callable[..., Awaitable[None]]]</code> <p>wrapped method</p> Source code in <code>src/machine/plugins/decorators.py</code> <pre><code>def require_any_role(\n    required_roles: list[str],\n) -&gt; Callable[[Callable[..., Awaitable[None]]], Callable[..., Awaitable[None]]]:\n    \"\"\"Specify required roles for a plugin method\n\n    To use the plugin method where this decorator is applied, the user must have\n    at least one of the listed roles.\n\n    Args:\n        required_roles: list of roles required to use the plugin method\n\n    Returns:\n        wrapped method\n    \"\"\"\n\n    def middle(func: Callable[..., Awaitable[None]]) -&gt; Callable[..., Awaitable[None]]:\n        async def wrapper(self: MachineBasePlugin, msg: Message, **kwargs: Any) -&gt; None:\n            if await matching_roles_by_user_id(self, msg.sender.id, required_roles):\n                logger.debug(f\"User {msg.sender} has one of the required roles {required_roles}\")\n                return await func(self, msg, **kwargs)\n            else:\n                logger.debug(f\"User {msg.sender} does not have any of the required roles {required_roles}\")\n                ee.emit(\n                    \"unauthorized-access\",\n                    self,\n                    message=msg,\n                    required_roles=required_roles,\n                    combinator=RoleCombinator.ANY,\n                )\n                await msg.say(\"I'm sorry, but you don't have access to that command\", ephemeral=True)\n                return None\n\n        # Copy any existing docs and metadata from container function to\n        # generated function\n        wrapper.__doc__ = func.__doc__\n        casted_wrapper = cast(DecoratedPluginFunc, wrapper)\n        casted_wrapper.metadata = getattr(func, \"metadata\", Metadata())\n        return casted_wrapper\n\n    return middle\n</code></pre>"},{"location":"api/#machine.plugins.decorators.require_all_roles","title":"<code>require_all_roles(required_roles: list[str]) -&gt; Callable[[Callable[..., Awaitable[None]]], Callable[..., Awaitable[None]]]</code>","text":"<p>Specify required roles for a plugin method</p> <p>To use the plugin method where this decorator is applied, the user must have all of the listed roles.</p> <p>Parameters:</p> Name Type Description Default <code>required_roles</code> <code>list[str]</code> <p>list of roles required to use the plugin method</p> required <p>Returns:</p> Type Description <code>Callable[[Callable[..., Awaitable[None]]], Callable[..., Awaitable[None]]]</code> <p>wrapped method</p> Source code in <code>src/machine/plugins/decorators.py</code> <pre><code>def require_all_roles(\n    required_roles: list[str],\n) -&gt; Callable[[Callable[..., Awaitable[None]]], Callable[..., Awaitable[None]]]:\n    \"\"\"Specify required roles for a plugin method\n\n    To use the plugin method where this decorator is applied, the user must have\n    all of the listed roles.\n\n    Args:\n        required_roles: list of roles required to use the plugin method\n\n    Returns:\n        wrapped method\n    \"\"\"\n\n    def middle(func: Callable[..., Awaitable[None]]) -&gt; Callable[..., Awaitable[None]]:\n        async def wrapper(self: MachineBasePlugin, msg: Message, **kwargs: Any) -&gt; None:\n            if await matching_roles_by_user_id(self, msg.sender.id, required_roles) == len(required_roles):\n                logger.debug(f\"User {msg.sender} has all of the required roles {required_roles}\")\n                return await func(self, msg, **kwargs)\n            else:\n                logger.debug(f\"User {msg.sender} does not have all of the required roles {required_roles}\")\n                ee.emit(\n                    \"unauthorized-access\",\n                    self,\n                    message=msg,\n                    required_roles=required_roles,\n                    combinator=RoleCombinator.ALL,\n                )\n                await msg.say(\"I'm sorry, but you don't have access to that command\", ephemeral=True)\n                return None\n\n        # Copy any existing docs and metadata from container function to\n        # generated function\n        wrapper.__doc__ = func.__doc__\n        casted_wrapper = cast(DecoratedPluginFunc, wrapper)\n        casted_wrapper.metadata = getattr(func, \"metadata\", Metadata())\n        return casted_wrapper\n\n    return middle\n</code></pre>"},{"location":"api/#models","title":"Models","text":"<p>These classes represent base objects from the Slack API</p>"},{"location":"api/#machine.models.user.User","title":"<code>machine.models.user.User</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>User model that represents a user object from the Slack API</p> Source code in <code>src/machine/models/user.py</code> <pre><code>class User(BaseModel):\n    \"\"\"User model that represents a user object from the Slack API\"\"\"\n\n    model_config = ConfigDict(frozen=True)\n\n    id: str\n    team_id: Optional[str] = None\n    name: str\n    deleted: Optional[bool] = None\n    profile: Profile\n    is_bot: bool\n    updated: int\n    is_app_user: bool\n    color: Optional[str] = None\n    real_name: Optional[str] = None\n    tz: Optional[str] = None\n    tz_label: Optional[str] = None\n    tz_offset: Optional[int] = None\n    is_admin: Optional[bool] = None\n    is_owner: Optional[bool] = None\n    is_primary_owner: Optional[bool] = None\n    is_restricted: Optional[bool] = None\n    is_ultra_restricted: Optional[bool] = None\n    is_stranger: Optional[bool] = None\n    has_2fa: Optional[bool] = None\n    locale: Optional[str] = None\n\n    def fmt_mention(self) -&gt; str:\n        \"\"\"Format the user as a mention\"\"\"\n        return f\"&lt;@{self.id}&gt;\"\n</code></pre>"},{"location":"api/#machine.models.user.User.fmt_mention","title":"<code>fmt_mention() -&gt; str</code>","text":"<p>Format the user as a mention</p> Source code in <code>src/machine/models/user.py</code> <pre><code>def fmt_mention(self) -&gt; str:\n    \"\"\"Format the user as a mention\"\"\"\n    return f\"&lt;@{self.id}&gt;\"\n</code></pre>"},{"location":"api/#machine.models.channel.Channel","title":"<code>machine.models.channel.Channel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Channel model that represents a channel object from the Slack API</p> Source code in <code>src/machine/models/channel.py</code> <pre><code>class Channel(BaseModel):\n    \"\"\"Channel model that represents a channel object from the Slack API\"\"\"\n\n    model_config = ConfigDict(frozen=True)\n\n    id: str\n    name: Optional[str] = None\n    created: int\n    creator: Optional[str] = None\n    is_archived: bool\n    is_general: Optional[bool] = None\n    name_normalized: Optional[str] = None\n    is_shared: Optional[bool] = None\n    is_org_shared: bool\n    is_member: Optional[bool] = None\n    is_private: Optional[bool] = None\n    is_mpim: Optional[bool] = None\n    is_channel: Optional[bool] = None\n    is_group: Optional[bool] = None\n    is_im: Optional[bool] = None\n    user: Optional[str] = None\n    topic: Optional[PurposeTopic] = None\n    purpose: Optional[PurposeTopic] = None\n    previous_names: Optional[list[str]] = None\n\n    @property\n    def identifier(self) -&gt; str:\n        \"\"\"Return the name of the channel if it exists, otherwise return the id\"\"\"\n        if self.name:\n            return self.name\n        else:\n            return self.id\n</code></pre>"},{"location":"api/#machine.models.channel.Channel.identifier","title":"<code>identifier: str</code>  <code>property</code>","text":"<p>Return the name of the channel if it exists, otherwise return the id</p>"},{"location":"api/#machine.models.interactive.BlockActionsPayload","title":"<code>machine.models.interactive.BlockActionsPayload</code>","text":"<p>               Bases: <code>TypedModel</code></p> Source code in <code>src/machine/models/interactive.py</code> <pre><code>class BlockActionsPayload(TypedModel):\n    type: Literal[\"block_actions\"]\n    user: User\n    api_app_id: str\n    token: str\n    container: Container\n    trigger_id: str\n    team: Team\n    enterprise: Enterprise | None\n    is_enterprise_install: bool\n    channel: Channel | None = None\n    message: Message | None = None\n    view: View | None = None\n    state: State | None = None\n    response_url: str | None = None\n    actions: list[Action]\n\n    @model_validator(mode=\"after\")\n    def validate_view_or_message(self) -&gt; BlockActionsPayload:\n        if self.view is None and self.message is None:\n            raise ValueError(\"Either view or message must be present!\")\n        if self.message is not None:\n            if self.channel is None:\n                raise ValueError(\"channel must be present when message is present!\")\n            if self.state is None:\n                raise ValueError(\"state must be present when message is present!\")\n            if self.response_url is None:\n                raise ValueError(\"response_url must be present when message is present!\")\n        return self\n</code></pre>"},{"location":"api/#machine.models.interactive.Action","title":"<code>machine.models.interactive.Action = Annotated[Union[RadioButtonsAction, ButtonAction, CheckboxAction, DatepickerAction, StaticSelectAction, ChannelSelectAction, ConversationSelectAction, UserSelectAction, ExternalSelectAction, MultiStaticSelectAction, MultiChannelSelectAction, MultiConversationSelectAction, MultiUserSelectAction, MultiExternalSelectAction, TimepickerAction, UrlAction, OverflowAction, PlainTextInputAction, RichTextInputAction], Field(discriminator='type')]</code>  <code>module-attribute</code>","text":""},{"location":"api/#machine.models.interactive.ViewSubmissionPayload","title":"<code>machine.models.interactive.ViewSubmissionPayload</code>","text":"<p>               Bases: <code>TypedModel</code></p> Source code in <code>src/machine/models/interactive.py</code> <pre><code>class ViewSubmissionPayload(TypedModel):\n    type: Literal[\"view_submission\"]\n    team: Team\n    user: User\n    view: View\n    enterprise: Enterprise | None\n    api_app_id: str\n    token: str\n    trigger_id: str\n    response_urls: list[ResponseUrlForView]\n    is_enterprise_install: bool\n</code></pre>"},{"location":"api/#machine.models.interactive.View","title":"<code>machine.models.interactive.View</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/machine/models/interactive.py</code> <pre><code>class View(BaseModel):\n    id: str\n    team_id: str\n    type: Literal[\"modal\", \"home\"]\n    blocks: list[Block]\n    private_metadata: str\n    callback_id: str\n    state: State\n    hash: str\n    title: Text\n    clear_on_close: bool\n    notify_on_close: bool\n    close: Text | None\n    submit: Text | None\n    previous_view_id: str | None\n    root_view_id: str\n    app_id: str\n    external_id: str\n    app_installed_team_id: str\n    bot_id: str\n</code></pre>"},{"location":"api/#machine.models.interactive.State","title":"<code>machine.models.interactive.State</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/machine/models/interactive.py</code> <pre><code>class State(BaseModel):\n    values: dict[str, dict[str, Values]]\n</code></pre>"},{"location":"api/#storage","title":"Storage","text":"<p>Storage is exposed to plugins through the <code>self.storage</code> field. The following class implements the interface plugins can use to interact with the storage backend.</p> <p>New Storage Backends can be implemented by extending the following class:</p>"},{"location":"api/#machine.storage.PluginStorage","title":"<code>machine.storage.PluginStorage</code>","text":"<p>Class providing access to persistent storage for plugins</p> <p>This class is the main access point for plugins to work with persistent storage. It is accessible from plugins using <code>self.storage</code>. Data is serialized before sending it to the storage backend, and deserialized upon retrieval. Serialization is done by dill, so pretty much any Python object can be stored and retrieved.</p> Source code in <code>src/machine/storage/__init__.py</code> <pre><code>class PluginStorage:\n    \"\"\"Class providing access to persistent storage for plugins\n\n    This class is the main access point for plugins to work with persistent storage. It is\n    accessible from plugins using `self.storage`. Data is serialized before sending it to\n    the storage backend, and deserialized upon retrieval. Serialization is done by [dill], so\n    pretty much any Python object can be stored and retrieved.\n\n    [dill]: https://pypi.python.org/pypi/dill\n    \"\"\"\n\n    def __init__(self, fq_plugin_name: str, storage_backend: MachineBaseStorage):\n        self._fq_plugin_name = fq_plugin_name\n        self._storage = storage_backend\n\n    def _gen_unique_key(self, key: str) -&gt; str:\n        return f\"{self._fq_plugin_name}:{key}\"\n\n    def _namespace_key(self, key: str, shared: bool = False) -&gt; str:\n        return key if shared else self._gen_unique_key(key)\n\n    async def set(self, key: str, value: Any, expires: int | timedelta | None = None, shared: bool = False) -&gt; None:\n        \"\"\"Store or update a value by key\n\n        Args:\n            key: the key under which to store the data\n            value: the data to store\n            expires: optional number of seconds after which the data is expired\n            shared: `True/False` wether this data should be shared by other plugins. Use with care, because it\n                pollutes the global namespace of the storage.\n        \"\"\"\n        expires = int(expires.total_seconds()) if isinstance(expires, timedelta) else expires\n        namespaced_key = self._namespace_key(key, shared)\n        pickled_value = dill.dumps(value)\n        await self._storage.set(namespaced_key, pickled_value, expires)\n\n    async def get(self, key: str, shared: bool = False) -&gt; Any | None:\n        \"\"\"Retrieve data by key\n\n        Args:\n            key: key for the data to retrieve\n            shared: `True/False` wether to retrieve data from the shared (global) namespace.\n\n        Returns:\n            the data, or `None` if the key cannot be found/has expired\n        \"\"\"\n        namespaced_key = self._namespace_key(key, shared)\n        value = await self._storage.get(namespaced_key)\n        if value:\n            return dill.loads(value)\n        else:\n            return None\n\n    async def has(self, key: str, shared: bool = False) -&gt; bool:\n        \"\"\"Check if the key exists in storage\n\n        Note:\n            this class implements `__contains__` so instead of calling\n            `self.storage.has(...)`, you can also use: `key in self.storage`. This will check the\n            _namespaced_ version of the key, so it's the same as: `self.storage.has('key', shared=False)`\n\n        Args:\n            key: key to check\n            shared: `True/False` wether to check in the shared (global) namespace\n\n        Returns:\n            `True/False` wether the key exists. Can only return `True` if the key has not\n                expired.\n        \"\"\"\n        namespaced_key = self._namespace_key(key, shared)\n        return await self._storage.has(namespaced_key)\n\n    async def delete(self, key: str, shared: bool = False) -&gt; None:\n        \"\"\"Remove a key and its data from storage\n\n        Args:\n            key: key to remove\n            shared: `True/False` wether the key to remove should be in the shared (global)\n                namespace\n        \"\"\"\n        namespaced_key = self._namespace_key(key, shared)\n        await self._storage.delete(namespaced_key)\n\n    async def get_storage_size(self) -&gt; int:\n        \"\"\"Calculate the total size of the storage\n\n        Returns:\n            the total size of the storage in bytes (integer)\n        \"\"\"\n        return await self._storage.size()\n\n    async def get_storage_size_human(self) -&gt; str:\n        \"\"\"Calculate the total size of the storage in human readable format\n\n        Returns:\n            the total size of the storage in a human readable string, rounded to the nearest\n                applicable division. eg. B for Bytes, KiB for Kilobytes, MiB for Megabytes etc.\n        \"\"\"\n        size = await self.get_storage_size()\n        return sizeof_fmt(size)\n</code></pre>"},{"location":"api/#machine.storage.PluginStorage.set","title":"<code>set(key: str, value: Any, expires: int | timedelta | None = None, shared: bool = False) -&gt; None</code>  <code>async</code>","text":"<p>Store or update a value by key</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>the key under which to store the data</p> required <code>value</code> <code>Any</code> <p>the data to store</p> required <code>expires</code> <code>int | timedelta | None</code> <p>optional number of seconds after which the data is expired</p> <code>None</code> <code>shared</code> <code>bool</code> <p><code>True/False</code> wether this data should be shared by other plugins. Use with care, because it pollutes the global namespace of the storage.</p> <code>False</code> Source code in <code>src/machine/storage/__init__.py</code> <pre><code>async def set(self, key: str, value: Any, expires: int | timedelta | None = None, shared: bool = False) -&gt; None:\n    \"\"\"Store or update a value by key\n\n    Args:\n        key: the key under which to store the data\n        value: the data to store\n        expires: optional number of seconds after which the data is expired\n        shared: `True/False` wether this data should be shared by other plugins. Use with care, because it\n            pollutes the global namespace of the storage.\n    \"\"\"\n    expires = int(expires.total_seconds()) if isinstance(expires, timedelta) else expires\n    namespaced_key = self._namespace_key(key, shared)\n    pickled_value = dill.dumps(value)\n    await self._storage.set(namespaced_key, pickled_value, expires)\n</code></pre>"},{"location":"api/#machine.storage.PluginStorage.get","title":"<code>get(key: str, shared: bool = False) -&gt; Any | None</code>  <code>async</code>","text":"<p>Retrieve data by key</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>key for the data to retrieve</p> required <code>shared</code> <code>bool</code> <p><code>True/False</code> wether to retrieve data from the shared (global) namespace.</p> <code>False</code> <p>Returns:</p> Type Description <code>Any | None</code> <p>the data, or <code>None</code> if the key cannot be found/has expired</p> Source code in <code>src/machine/storage/__init__.py</code> <pre><code>async def get(self, key: str, shared: bool = False) -&gt; Any | None:\n    \"\"\"Retrieve data by key\n\n    Args:\n        key: key for the data to retrieve\n        shared: `True/False` wether to retrieve data from the shared (global) namespace.\n\n    Returns:\n        the data, or `None` if the key cannot be found/has expired\n    \"\"\"\n    namespaced_key = self._namespace_key(key, shared)\n    value = await self._storage.get(namespaced_key)\n    if value:\n        return dill.loads(value)\n    else:\n        return None\n</code></pre>"},{"location":"api/#machine.storage.PluginStorage.has","title":"<code>has(key: str, shared: bool = False) -&gt; bool</code>  <code>async</code>","text":"<p>Check if the key exists in storage</p> Note <p>this class implements <code>__contains__</code> so instead of calling <code>self.storage.has(...)</code>, you can also use: <code>key in self.storage</code>. This will check the namespaced version of the key, so it's the same as: <code>self.storage.has('key', shared=False)</code></p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>key to check</p> required <code>shared</code> <code>bool</code> <p><code>True/False</code> wether to check in the shared (global) namespace</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True/False</code> wether the key exists. Can only return <code>True</code> if the key has not expired.</p> Source code in <code>src/machine/storage/__init__.py</code> <pre><code>async def has(self, key: str, shared: bool = False) -&gt; bool:\n    \"\"\"Check if the key exists in storage\n\n    Note:\n        this class implements `__contains__` so instead of calling\n        `self.storage.has(...)`, you can also use: `key in self.storage`. This will check the\n        _namespaced_ version of the key, so it's the same as: `self.storage.has('key', shared=False)`\n\n    Args:\n        key: key to check\n        shared: `True/False` wether to check in the shared (global) namespace\n\n    Returns:\n        `True/False` wether the key exists. Can only return `True` if the key has not\n            expired.\n    \"\"\"\n    namespaced_key = self._namespace_key(key, shared)\n    return await self._storage.has(namespaced_key)\n</code></pre>"},{"location":"api/#machine.storage.PluginStorage.delete","title":"<code>delete(key: str, shared: bool = False) -&gt; None</code>  <code>async</code>","text":"<p>Remove a key and its data from storage</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>key to remove</p> required <code>shared</code> <code>bool</code> <p><code>True/False</code> wether the key to remove should be in the shared (global) namespace</p> <code>False</code> Source code in <code>src/machine/storage/__init__.py</code> <pre><code>async def delete(self, key: str, shared: bool = False) -&gt; None:\n    \"\"\"Remove a key and its data from storage\n\n    Args:\n        key: key to remove\n        shared: `True/False` wether the key to remove should be in the shared (global)\n            namespace\n    \"\"\"\n    namespaced_key = self._namespace_key(key, shared)\n    await self._storage.delete(namespaced_key)\n</code></pre>"},{"location":"api/#machine.storage.PluginStorage.get_storage_size","title":"<code>get_storage_size() -&gt; int</code>  <code>async</code>","text":"<p>Calculate the total size of the storage</p> <p>Returns:</p> Type Description <code>int</code> <p>the total size of the storage in bytes (integer)</p> Source code in <code>src/machine/storage/__init__.py</code> <pre><code>async def get_storage_size(self) -&gt; int:\n    \"\"\"Calculate the total size of the storage\n\n    Returns:\n        the total size of the storage in bytes (integer)\n    \"\"\"\n    return await self._storage.size()\n</code></pre>"},{"location":"api/#machine.storage.PluginStorage.get_storage_size_human","title":"<code>get_storage_size_human() -&gt; str</code>  <code>async</code>","text":"<p>Calculate the total size of the storage in human readable format</p> <p>Returns:</p> Type Description <code>str</code> <p>the total size of the storage in a human readable string, rounded to the nearest applicable division. eg. B for Bytes, KiB for Kilobytes, MiB for Megabytes etc.</p> Source code in <code>src/machine/storage/__init__.py</code> <pre><code>async def get_storage_size_human(self) -&gt; str:\n    \"\"\"Calculate the total size of the storage in human readable format\n\n    Returns:\n        the total size of the storage in a human readable string, rounded to the nearest\n            applicable division. eg. B for Bytes, KiB for Kilobytes, MiB for Megabytes etc.\n    \"\"\"\n    size = await self.get_storage_size()\n    return sizeof_fmt(size)\n</code></pre>"},{"location":"api/#machine.storage.backends.base.MachineBaseStorage","title":"<code>machine.storage.backends.base.MachineBaseStorage</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for storage backends</p> <p>Extending classes should implement the five methods in this base class. Slack Machine takes care of a lot of details regarding the persistent storage of data. So storage backends do not have to deal with the following, because Slack Machine takes care of these:</p> <ul> <li>Serialization/Deserialization of data</li> <li>Namespacing of keys (so data stored by different plugins doesn't clash)</li> </ul> Source code in <code>src/machine/storage/backends/base.py</code> <pre><code>class MachineBaseStorage(ABC):\n    \"\"\"Base class for storage backends\n\n    Extending classes should implement the five methods in this base class. Slack Machine takes\n    care of a lot of details regarding the persistent storage of data. So storage backends\n    **do not** have to deal with the following, because Slack Machine takes care of these:\n\n    - Serialization/Deserialization of data\n    - Namespacing of keys (so data stored by different plugins doesn't clash)\n    \"\"\"\n\n    settings: Mapping[str, Any]\n\n    def __init__(self, settings: Mapping[str, Any]):\n        self.settings = settings\n\n    async def init(self) -&gt; None:  # noqa: B027 (no-op by design)\n        \"\"\"Initialize the storage backend\n\n        To be implemented by subclasses if initialization is required. This method is called once after instantiation.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    async def get(self, key: str) -&gt; bytes | None:\n        \"\"\"Retrieve data by key\n\n        Args:\n            key: key for which to retrieve data\n\n        Returns:\n            the raw data for the provided key, as (byte)string. Should return `None` when\n                the key is unknown or the data has expired.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    async def set(self, key: str, value: bytes, expires: int | None = None) -&gt; None:\n        \"\"\"Store data by key\n\n        Args:\n            key: the key under which to store the data\n            value: data as (byte)string\n            expires: optional expiration time in seconds, after which the data should not be\n                returned any more.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    async def delete(self, key: str) -&gt; None:\n        \"\"\"Delete data by key\n\n        :param key: key for which to delete the data\n        \"\"\"\n        ...\n\n    @abstractmethod\n    async def has(self, key: str) -&gt; bool:\n        \"\"\"Check if the key exists\n\n        Args:\n            key: key to check\n\n        Returns:\n            `True/False` wether the key exists\n        \"\"\"\n        ...\n\n    @abstractmethod\n    async def size(self) -&gt; int:\n        \"\"\"Calculate the total size of the storage\n\n        Returns:\n            total size of storage in bytes (integer)\n        \"\"\"\n        ...\n\n    @abstractmethod\n    async def close(self) -&gt; None:\n        \"\"\"Close the storage backend\"\"\"\n        ...\n</code></pre>"},{"location":"api/#machine.storage.backends.base.MachineBaseStorage.init","title":"<code>init() -&gt; None</code>  <code>async</code>","text":"<p>Initialize the storage backend</p> <p>To be implemented by subclasses if initialization is required. This method is called once after instantiation.</p> Source code in <code>src/machine/storage/backends/base.py</code> <pre><code>async def init(self) -&gt; None:  # noqa: B027 (no-op by design)\n    \"\"\"Initialize the storage backend\n\n    To be implemented by subclasses if initialization is required. This method is called once after instantiation.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/#machine.storage.backends.base.MachineBaseStorage.get","title":"<code>get(key: str) -&gt; bytes | None</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Retrieve data by key</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>key for which to retrieve data</p> required <p>Returns:</p> Type Description <code>bytes | None</code> <p>the raw data for the provided key, as (byte)string. Should return <code>None</code> when the key is unknown or the data has expired.</p> Source code in <code>src/machine/storage/backends/base.py</code> <pre><code>@abstractmethod\nasync def get(self, key: str) -&gt; bytes | None:\n    \"\"\"Retrieve data by key\n\n    Args:\n        key: key for which to retrieve data\n\n    Returns:\n        the raw data for the provided key, as (byte)string. Should return `None` when\n            the key is unknown or the data has expired.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/#machine.storage.backends.base.MachineBaseStorage.set","title":"<code>set(key: str, value: bytes, expires: int | None = None) -&gt; None</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Store data by key</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>the key under which to store the data</p> required <code>value</code> <code>bytes</code> <p>data as (byte)string</p> required <code>expires</code> <code>int | None</code> <p>optional expiration time in seconds, after which the data should not be returned any more.</p> <code>None</code> Source code in <code>src/machine/storage/backends/base.py</code> <pre><code>@abstractmethod\nasync def set(self, key: str, value: bytes, expires: int | None = None) -&gt; None:\n    \"\"\"Store data by key\n\n    Args:\n        key: the key under which to store the data\n        value: data as (byte)string\n        expires: optional expiration time in seconds, after which the data should not be\n            returned any more.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/#machine.storage.backends.base.MachineBaseStorage.delete","title":"<code>delete(key: str) -&gt; None</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Delete data by key</p> <p>:param key: key for which to delete the data</p> Source code in <code>src/machine/storage/backends/base.py</code> <pre><code>@abstractmethod\nasync def delete(self, key: str) -&gt; None:\n    \"\"\"Delete data by key\n\n    :param key: key for which to delete the data\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/#machine.storage.backends.base.MachineBaseStorage.has","title":"<code>has(key: str) -&gt; bool</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Check if the key exists</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>key to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True/False</code> wether the key exists</p> Source code in <code>src/machine/storage/backends/base.py</code> <pre><code>@abstractmethod\nasync def has(self, key: str) -&gt; bool:\n    \"\"\"Check if the key exists\n\n    Args:\n        key: key to check\n\n    Returns:\n        `True/False` wether the key exists\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/#machine.storage.backends.base.MachineBaseStorage.size","title":"<code>size() -&gt; int</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Calculate the total size of the storage</p> <p>Returns:</p> Type Description <code>int</code> <p>total size of storage in bytes (integer)</p> Source code in <code>src/machine/storage/backends/base.py</code> <pre><code>@abstractmethod\nasync def size(self) -&gt; int:\n    \"\"\"Calculate the total size of the storage\n\n    Returns:\n        total size of storage in bytes (integer)\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/#machine.storage.backends.base.MachineBaseStorage.close","title":"<code>close() -&gt; None</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Close the storage backend</p> Source code in <code>src/machine/storage/backends/base.py</code> <pre><code>@abstractmethod\nasync def close(self) -&gt; None:\n    \"\"\"Close the storage backend\"\"\"\n    ...\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, with a smattering of Common Changelog thrown in, most notably references, authors and prefixes. This project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#0401-2025-08-20","title":"0.40.1 - 2025-08-20","text":""},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Bumped various dependencies</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Update <code>enterprise</code> model type to adhere to the Slack API   (#1260 by   @AlexanderOtavka)</li> </ul>"},{"location":"changelog/#0400-2024-11-24","title":"0.40.0 - 2024-11-24","text":""},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Replace Poetry with uv (#1218)</li> <li>Replace Tox with Nox (#1218)</li> <li>Replace Dependabot with Renovate   (#1220)</li> <li>Bump <code>pydantic</code> from 2.10.0 to 2.10.1</li> </ul>"},{"location":"changelog/#0390-2024-11-22","title":"0.39.0 - 2024-11-22","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Add support for modals   (#1052)</li> </ul>"},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>Bump <code>slack-sdk</code> from 3.33.3 to 3.33.4 (fixes incompatibility with newer versions of <code>aiohttp</code>)</li> <li>Bump <code>pydantic</code> from 2.9.2 to 2.10.0</li> <li>Bump <code>aiohttp</code> from 3.10.11 to 3.11.7</li> </ul>"},{"location":"changelog/#0381-2024-11-17","title":"0.38.1 - 2024-11-17","text":""},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li><code>aiohttp</code> versions 3.11.0 and higher were causing issues, so <code>aiohttp</code> is temporarily restricted to versions &lt; 3.11   (#1201)</li> </ul>"},{"location":"changelog/#0380-2024-11-16","title":"0.38.0 - 2024-11-16","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Add Python 3.13 support (#1199)</li> </ul>"},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>Bump <code>slack-sdk</code> from 3.27.2 to 3.33.3</li> <li>Bump <code>pydantic</code> from 2.7.1 to 2.9.2</li> <li>Bump <code>structlog</code> from 24.1.0 to 24.4.0</li> <li>Bump <code>redis</code> from 5.0.4 to 5.2.0</li> <li>Bump <code>hiredis</code> from 2.3.2 to 3.0.0</li> <li>Bump <code>aioboto3</code> from 12.4.0 to 13.2.0</li> <li>Bump <code>urllib3</code> from 1.26.18 to 1.26.19</li> <li>Bump <code>httpx</code> from 0.27.0 to 0.27.2</li> <li>Bump <code>multidict</code> from 6.0.5 to 6.1.0</li> <li>Bump <code>cryptography</code> from 42.0.4 to 43.0.1</li> <li>Bump <code>aiohttp</code> from 3.9.5 to 3.10.11</li> <li>Bump <code>tzdata</code> from 2024.1 to 2024.2</li> <li>Bump <code>dill</code> from 0.3.8 to 0.3.9</li> </ul>"},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Add rate limit handling to Slack client to improve Slack Machine's resilience when interacting with Slack's API,   especially when working with large workspaces (#1194 by   @sprutner and @jasonwbarnett)</li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>Breaking: Remove Python 3.8 support (#1199)</li> </ul>"},{"location":"changelog/#0370-2024-05-26","title":"0.37.0 - 2024-05-26","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Support for Block actions, coming from interactive elements from Block Kit   (#1034 with help from   pawelros)</li> </ul>"},{"location":"changelog/#changed_4","title":"Changed","text":"<ul> <li>Bump <code>slack-sdk</code> from 3.27.1 to 3.27.2</li> </ul>"},{"location":"changelog/#0360-2024-05-04","title":"0.36.0 - 2024-05-04","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Replace <code>flake8</code>, <code>isort</code> and <code>black</code> with <code>ruff</code> (#1027)</li> <li>Add Python 3.12 (#1028)</li> </ul>"},{"location":"changelog/#changed_5","title":"Changed","text":"<ul> <li>Update Github Actions (#1008)</li> <li>Bump <code>slack-sdk</code> from 3.21.3 to 3.27.1</li> <li>Bump <code>httpx</code> from 0.24.1 to 0.27.0</li> <li>Bump <code>pydantic</code> from 2.3.0 to 2.7.1</li> <li>Bump <code>cryptography</code> from 41.0.3 to 42.0.4</li> <li>Bump <code>aiohttp</code> from 3.8.5 to 3.9.5</li> <li>Bump <code>urllib3</code> from 1.26.16 1.26.18</li> <li>Bump <code>structlog</code> from 23.1.0 to 24.1.0</li> <li>Bump <code>redis</code> from 5.0.0 to 5.0.4</li> <li>Bump <code>pyee</code> from 11.0.0 to 11.1.0</li> <li>Bump <code>aioboto3</code> from 11.3.0 to 12.4.0</li> <li>Bump <code>tzdata</code> from 2023.3 to 2024.1</li> <li>Bump <code>aiosqlite</code> from 0.19.0 to 0.20.0</li> <li>Bump <code>hiredis</code> from 2.2.3 to 2.3.2</li> </ul>"},{"location":"changelog/#0350-2023-09-03","title":"0.35.0 - 2023-09-03","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Incoming requests/events from Slack that the Slack App is subscribed to, will be logged when <code>LOGLEVEL</code> is set to   <code>DEBUG</code> (#876)</li> </ul>"},{"location":"changelog/#changed_6","title":"Changed","text":"<ul> <li>Breaking: the optional <code>init()</code> method of plugins is now expected to be <code>async</code>. This allows plugin authors to   interact with Slack during plugin initialization through Slack Machine's plugin API.   (#868)</li> <li>Standard app manifest for Slack Machine now also enables listening for the <code>app_home_opened</code> event</li> <li>Bump <code>aiosqlite</code> from 0.18.0 to 0.19.0</li> <li>Bump <code>apscheduler</code> from 3.10.1 to 3.10.4</li> <li>Bump <code>redis</code> from 4.6.0 to 5.0.0</li> <li>Bump <code>pyee</code> from 10.0.2 to 11.0.0</li> <li>Bump <code>pydantic</code> from 2.2.1 to 2.3.0</li> </ul>"},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li>Use conversations_setTopic instead of channels_setTopic for setting channel topic   (#869 by   @jogendra)</li> </ul>"},{"location":"changelog/#0342-2023-08-13","title":"0.34.2 - 2023-08-13","text":""},{"location":"changelog/#fixed_4","title":"Fixed","text":"<ul> <li>Users indexed by email and related functions are now exposed through the plugin interface   (#852)</li> </ul>"},{"location":"changelog/#0341-2023-08-13","title":"0.34.1 - 2023-08-13","text":""},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li>Slack users are now indexed by their email as well, allowing fast lookups by email   (#849)</li> </ul>"},{"location":"changelog/#fixed_5","title":"Fixed","text":"<ul> <li>All logging in Slack Machine is now done through structlog instead of the Python stdlib logger   (#850)</li> </ul>"},{"location":"changelog/#0340-2023-08-13","title":"0.34.0 - 2023-08-13","text":""},{"location":"changelog/#added_6","title":"Added","text":"<ul> <li>Add support to set topic on channels (#839 by   @jogendra)</li> <li>Add SQLite storage backend (#844 by   @cp-richard)</li> </ul>"},{"location":"changelog/#changed_7","title":"Changed","text":"<ul> <li>Bump <code>httpx</code> from 0.24.0 to 0.24.1</li> <li>Bump <code>aiohttp</code> from 3.8.4 to 3.8.5</li> <li>Bump <code>certifi</code> from 2022.12.7 to 2023.7.22</li> <li>Bump <code>pyee</code> from 9.1.0 to 10.0.2</li> <li>Bump <code>pydantic</code> from 1.10.7 to 2.1.1 (#840)</li> </ul>"},{"location":"changelog/#removed_1","title":"Removed","text":"<ul> <li>Breaking: Remove Python 3.7 support (#846)</li> </ul>"},{"location":"changelog/#0330-2023-05-15","title":"0.33.0 - 2023-05-15","text":""},{"location":"changelog/#added_7","title":"Added","text":"<ul> <li>Add support for slash commands   (#787)</li> </ul>"},{"location":"changelog/#changed_8","title":"Changed","text":"<ul> <li>Breaking: move <code>Message</code> class from <code>machine.plugins.base</code> to <code>machine.plugins.message</code></li> <li>Use dots only for referencing the fully-qualified name of classes and functions instead of using a colon before   the class name</li> <li>Bump <code>tzdata</code> from 2022.6 to 2023.3</li> <li>Bump <code>slack-sdk</code> from 3.19.4 to 3.21.3</li> <li>Bump <code>aioboto3</code> from 10.1.0 to 11.2.0</li> <li>Bump <code>aiohttp</code> from 3.8.3 to 3.8.4</li> <li>Bump <code>redis</code> from 4.3.5 to 4.5.5</li> <li>Bump <code>hiredis</code> from 2.0.0 to 2.2.3</li> <li>Bump <code>pydantic</code> from 1.10.2 to 1.10.7</li> <li>Bump <code>httpx</code> from 0.23.1 to 0.24.0</li> <li>Bump <code>apscheduler</code> from 3.9.1.post1 to 3.10.1</li> <li>Bump <code>structlog</code> from 22.3.0 to 23.1.0</li> <li>Bump <code>pyee</code> from 9.0.4 to 9.1.0</li> </ul>"},{"location":"changelog/#0320-2022-11-27","title":"0.32.0 - 2022-11-27","text":""},{"location":"changelog/#added_8","title":"Added","text":"<ul> <li>Add Python 3.11 support (#676)</li> <li>Expose web client of Slack SDK (#677)</li> </ul>"},{"location":"changelog/#changed_9","title":"Changed","text":"<ul> <li>Bump <code>dill</code> from 0.3.5.1 to 0.3.6</li> <li>Bump <code>slack-sdk</code> from 3.19.1 to 3.19.4</li> <li>Bump <code>tzdata</code> from 2022.5 to 2022.6</li> <li>Bump <code>apscheduler</code> from 3.9.1 to 3.9.1.post1</li> <li>Bump <code>httpx</code> from 0.23.0 to 0.23.1</li> <li>Bump <code>redis</code> from 4.3.4 to 4.3.5</li> <li>Bump <code>structlog</code> from 22.1.0 to 22.3.0</li> </ul>"},{"location":"changelog/#fixed_6","title":"Fixed","text":"<ul> <li>Fix documentation typos (#665 by   @bennylu2)</li> </ul>"},{"location":"changelog/#0310-2022-10-21","title":"0.31.0 - 2022-10-21","text":""},{"location":"changelog/#changed_10","title":"Changed","text":"<ul> <li>Moved Slack Machine community chat to Slack</li> <li>Type-hint coverage is now 100% so mypy is happy (#633)</li> <li>Update pyproject.toml to conform to Poetry 1.2 dependency specification   (#657)</li> <li>Replace <code>dacite</code> with <code>pydantic</code> to create models for Slack API interactions   (#659)</li> <li>Bump <code>aiohttp</code> from 3.8.1 to 3.8.3</li> <li>Bump <code>slack-sdk</code> from 3.18.3 to 3.19.1</li> <li>Bump <code>tzdata</code> from 2022.4 to 2022.5</li> <li>Bump <code>aioboto3</code> from 10.0.0 to 10.1.0</li> <li>Add changelog to keep track of updates</li> <li>Move to structlog for logging, fixes   #599   (#663)</li> </ul>"},{"location":"changelog/#removed_2","title":"Removed","text":"<ul> <li>Remove unused settings: <code>DISABLE_HTTP</code>, <code>HTTP_SERVER_HOST</code>, <code>HTTP_SERVER_PORT</code>, <code>HTTP_SERVER_BACKEND</code>, <code>HTTPS_PROXY</code>,   <code>KEEP_ALIVE</code></li> </ul>"},{"location":"changelog/#0300-2022-08-30","title":"0.30.0 - 2022-08-30","text":""},{"location":"changelog/#changed_11","title":"Changed","text":"<ul> <li>Bump <code>slack-sdk</code> from 3.18.1 to 3.18.3 (#619)</li> </ul>"},{"location":"changelog/#removed_3","title":"Removed","text":"<ul> <li>Breaking: Remove sync version, it's all async now baby! :dancing_men:</li> </ul>"},{"location":"changelog/#0282-2022-08-30","title":"0.28.2 - 2022-08-30","text":""},{"location":"changelog/#changed_12","title":"Changed","text":"<ul> <li>Make handling changed message configurable in async mode (#613)</li> <li>Add tests for slack client (#614)</li> </ul>"},{"location":"changelog/#0281-2022-08-28","title":"0.28.1 - 2022-08-28","text":""},{"location":"changelog/#added_9","title":"Added","text":"<ul> <li>Add support for pinning/unpinning of messages (#611)</li> </ul>"},{"location":"changelog/#changed_13","title":"Changed","text":"<ul> <li>Add support for listening to message change events (#594   with help from @cchadowitz-pf)</li> </ul>"},{"location":"changelog/#0280-2022-08-28","title":"0.28.0 - 2022-08-28","text":""},{"location":"changelog/#added_10","title":"Added","text":"<ul> <li>Add support to async version for scheduling messages and running plugin functions on a schedule   (#610)</li> </ul>"},{"location":"changelog/#0272-2022-08-14","title":"0.27.2 - 2022-08-14","text":""},{"location":"changelog/#fixed_7","title":"Fixed","text":"<ul> <li><code>aioboto3</code> types are only relevant for type checking, so move imports inside type checking guard</li> </ul>"},{"location":"changelog/#0271-2022-08-14","title":"0.27.1 - 2022-08-14","text":""},{"location":"changelog/#changed_14","title":"Changed","text":"<ul> <li>Add documentation for DynamoDB storage backend (#603)</li> </ul>"},{"location":"changelog/#fixed_8","title":"Fixed","text":"<ul> <li>Add <code>aioboto3</code> as optional dependency so extras can be satisfied (#604)</li> </ul>"},{"location":"changelog/#0270-2022-08-14","title":"0.27.0 - 2022-08-14","text":""},{"location":"changelog/#added_11","title":"Added","text":"<ul> <li>Add DynamoDB storage backend (#602 by   @jkmathes)</li> <li>Add <code>black</code>, <code>isort</code> and other linters/formatters to create uniform code style (#597)</li> </ul>"},{"location":"changelog/#changed_15","title":"Changed","text":"<ul> <li>Update documentation for builtin plugins, fixes #396   (#598)</li> <li>Replace <code>requests</code> with <code>httpx</code> for async http calls in meme plugin and share memes as blocks   (#600)</li> <li>Replace <code>requests</code> with <code>httpx</code> for async http calls in Google image search plugin (#601)</li> </ul>"},{"location":"changelog/#0261-2022-08-13","title":"0.26.1 - 2022-08-13","text":""},{"location":"changelog/#fixed_9","title":"Fixed","text":"<ul> <li>Various documentation fixes</li> <li>Fix project metadata</li> </ul>"},{"location":"changelog/#0260-2022-08-13","title":"0.26.0 - 2022-08-13","text":""},{"location":"changelog/#added_12","title":"Added","text":"<ul> <li>Slack Machine now supports asyncio using the Slack Events API   and Socket Mode! :racing_car:</li> </ul>"},{"location":"changelog/#changed_16","title":"Changed","text":"<ul> <li>Bump <code>redis</code> from 4.2.0 to 4.3.4</li> <li>Bump <code>slack-sdk</code> from 3.15.2 to 3.18.1</li> </ul>"},{"location":"changelog/#0250-2022-03-27","title":"0.25.0 - 2022-03-27","text":""},{"location":"changelog/#changed_17","title":"Changed","text":"<ul> <li>Bump <code>redis</code> from 4.0.2 to 4.2.0</li> <li>Bump <code>slack-sdk</code> from 3.12.0 to 3.15.2</li> <li>Bump <code>requests</code> from 2.26.0 to 2.27.1</li> <li>Bump <code>apscheduler</code> from 3.8.1 to 3.9.1</li> </ul>"},{"location":"changelog/#fixed_10","title":"Fixed","text":"<ul> <li>Fix expected payload of events when updating channel cache, fixes #526   (#565)</li> </ul>"},{"location":"changelog/#0240-2021-12-01","title":"0.24.0 - 2021-12-01","text":""},{"location":"changelog/#added_13","title":"Added","text":"<ul> <li>Add Python 3.10 support</li> </ul>"},{"location":"changelog/#changed_18","title":"Changed","text":"<ul> <li>Bump <code>redis</code> from 3.5.3 to 4.0.2</li> <li>Bump <code>apscheduler</code> from 3.8.0 to 3.8.1</li> <li>Move documentation from Sphinx to MkDocs and Material for MkDocs   for beautiful docs (#514)</li> <li>Switch from <code>slackclient</code> to <code>slack_sdk</code> library, fixes #443</li> </ul>"},{"location":"changelog/#removed_4","title":"Removed","text":"<ul> <li>Breaking: Remove Python 3.6 support</li> </ul>"},{"location":"changelog/#0232-2021-10-17","title":"0.23.2 - 2021-10-17","text":""},{"location":"changelog/#fixed_11","title":"Fixed","text":"<ul> <li>Bring back script to run Slack Machine</li> </ul>"},{"location":"changelog/#0231-2021-10-17","title":"0.23.1 - 2021-10-17","text":""},{"location":"changelog/#changed_19","title":"Changed","text":"<ul> <li>Document all contributors</li> </ul>"},{"location":"changelog/#fixed_12","title":"Fixed","text":"<ul> <li>Install the right extra packages for Redis</li> </ul>"},{"location":"changelog/#removed_5","title":"Removed","text":"<ul> <li>Breaking: HBase storage backend has been removed</li> </ul>"},{"location":"changelog/#0230-2021-10-16","title":"0.23.0 - 2021-10-16","text":""},{"location":"changelog/#changed_20","title":"Changed","text":"<ul> <li>Switch to Poetry for project and dependency management</li> <li>Bump <code>apscheduler</code> from 3.7.0 to 3.8.0</li> </ul>"},{"location":"changelog/#fixed_13","title":"Fixed","text":"<ul> <li>Various CI fixes</li> </ul>"},{"location":"changelog/#0220-2021-09-12","title":"0.22.0 - 2021-09-12","text":""},{"location":"changelog/#changed_21","title":"Changed","text":"<ul> <li>Bump <code>dill</code> from 0.3.3 to 0.3.4</li> <li>Bump <code>requests</code> from 2.25.1 to 2.26.0</li> <li>Bump <code>cython</code> from 0.29.23 to 0.29.24</li> <li>Use Github Actions for CI and drop Travis (#492)</li> <li>Switch <code>master</code> branch to <code>main</code> to get with the times</li> </ul>"},{"location":"changelog/#fixed_14","title":"Fixed","text":"<ul> <li>Only cover named channels when attempting to find a channel by name (#483   by @arusahni)</li> </ul>"},{"location":"changelog/#0211-2021-08-01","title":"0.21.1 - 2021-08-01","text":""},{"location":"changelog/#changed_22","title":"Changed","text":"<ul> <li>Add channel members to <code>Channel</code> model and keep members up-to-date through Slack events (#485   by @arusahni)</li> </ul>"},{"location":"changelog/#0210-2021-04-25","title":"0.21.0 - 2021-04-25","text":""},{"location":"changelog/#added_14","title":"Added","text":"<ul> <li>Add Gitter chat room to facilitate discussions about Slack Machine</li> <li>Add Role-based access controls feature for plugins (#321   by @davidolrik)</li> <li>Add Python 3.9 support</li> </ul>"},{"location":"changelog/#changed_23","title":"Changed","text":"<ul> <li>Move to Dependabot from PyUp to manage automatic dependency updates</li> <li>Bump <code>slackclient</code> from 2.7.3 to 2.9.3</li> <li>Bump <code>requests</code> from 2.24.0 to 2.25.1</li> <li>Bump <code>dill</code> from 0.3.2 to 0.3.3</li> <li>Bump <code>dacite</code> from 1.5.1 to 1.6.0</li> <li>Bump <code>cython</code> from 0.29.21 to 0.29.23</li> <li>Bump <code>apscheduler</code> from 3.6.3 to 3.7.0</li> </ul>"},{"location":"changelog/#fixed_15","title":"Fixed","text":"<ul> <li>Make channel topic creator an optional field in the <code>Channel</code> model (#439   by @eguven)</li> <li>Always respond to plugin functions decorated with <code>@listen_to</code>, also when bot is addressed in direct message (#436   by @eddyg)</li> <li>Use <code>conversations.open</code> endpoint on Slack WebAPI instead of <code>im.open</code> endpoint to open direct message conversations,   because the latter is deprecated (#401   by @cchadowitz-pf)</li> </ul>"},{"location":"changelog/#0201-2020-07-23","title":"0.20.1 - 2020-07-23","text":""},{"location":"changelog/#fixed_16","title":"Fixed","text":"<ul> <li>Use <code>conversations.info</code> endpoint on Slack WebAPI instead of <code>channels.info</code> endpoint, which is deprecated and   mark optional fields as such in <code>User</code> and <code>Channel</code> objects   (#386 by @repudi8or)</li> </ul>"},{"location":"changelog/#0200-2020-07-22","title":"0.20.0 - 2020-07-22","text":""},{"location":"changelog/#added_15","title":"Added","text":"<ul> <li>Support Python 3.8</li> </ul>"},{"location":"changelog/#changed_24","title":"Changed","text":"<ul> <li>Bump <code>dacite</code> from 1.0.2 to 1.5.1</li> <li>Bump <code>redis</code> from 3.3.11 to 3.5.3</li> <li>Bump <code>cython</code> from 0.29.14 to 0.29.21</li> <li>Bump <code>dill</code> from 0.3.1.1 to 0.3.2</li> <li>Bump <code>requests</code> from 2.22.0 to 2.24.0</li> <li>Bump <code>slackclient</code> from 2.5.0 to 2.7.3</li> <li>Add <code>is_thread</code> property to <code>Message</code> class (#286 by   @davidolrik)</li> <li>Use <code>conversations.list</code> endpoint on Slack WebAPI instead of <code>channels.list</code> endpoint, which is deprecated and   include private channels in channel cache (#329 by   @repudi8or)</li> <li>Include direct messages in channel cache</li> <li>Add pre-commit hooks to verify basic things before commiting</li> </ul>"},{"location":"changelog/#fixed_17","title":"Fixed","text":"<ul> <li><code>deleted</code> property is optional on user responses from Slack WebAPI</li> </ul>"},{"location":"changelog/#0192-2020-01-05","title":"0.19.2 - 2020-01-05","text":""},{"location":"changelog/#changed_25","title":"Changed","text":"<ul> <li>Breaking:: <code>thread_ts</code> property on the <code>Message</code> class has been renamed to <code>ts</code></li> </ul>"},{"location":"changelog/#fixed_18","title":"Fixed","text":"<ul> <li><code>EchoPlugin</code> will not respond to itself anymore</li> <li>Fixed PyPI classifiers</li> </ul>"},{"location":"changelog/#0191-2020-01-05","title":"0.19.1 - 2020-01-05","text":""},{"location":"changelog/#fixed_19","title":"Fixed","text":"<ul> <li>Fix help plugin</li> <li>Fix various typos in the documentation</li> </ul>"},{"location":"changelog/#0190-2020-01-05","title":"0.19.0 - 2020-01-05","text":""},{"location":"changelog/#changed_26","title":"Changed","text":"<ul> <li>Major version upgrade of <code>slackclient</code> from 1.3.1 to 2.5.0</li> <li>Refactor code to capture Slack API responses in dataclasses for easier development</li> <li>Split internal Slack client into low-level client and high-level facade</li> <li>Start adding type hints</li> <li>Breaking: <code>self.users</code> and <code>self.channels</code> on the base plugin class now return different objects than before.   See API documentation for more details. These properties should behave more consistently however, even in workspaces   with many users.</li> </ul>"},{"location":"changelog/#removed_6","title":"Removed","text":"<ul> <li>Breaking: Remove <code>catch_all()</code> method from base plugin class because it's not supported by the <code>slackclient</code>   library anymore</li> <li>Breaking: The <code>*_webapi</code> methods to send messages do not exist anymore, use the regular counterparts instead. All   messages are now sent using the Slack WebAPI. The RTM API is still used for listening to messages and events</li> </ul>"},{"location":"changelog/#0182-2019-11-17","title":"0.18.2 - 2019-11-17","text":""},{"location":"changelog/#fixed_20","title":"Fixed","text":"<ul> <li>Fix <code>bottle</code> import</li> </ul>"},{"location":"changelog/#0181-2019-11-17","title":"0.18.1 - 2019-11-17","text":""},{"location":"changelog/#changed_27","title":"Changed","text":"<ul> <li>Bump <code>apscheduler</code> from 3.5.3 to 3.6.3</li> <li>Bump <code>redis</code> from 3.2.0 to 3.3.11</li> <li>Bump <code>happybase</code> from 1.1.0 to 1.2.0</li> <li>Bump <code>cython</code> from 0.29.6 to 0.29.14</li> <li>Bump <code>dill</code> from 0.2.9 to 0.3.1.1</li> <li>Bump <code>bottle</code> from 0.12.16 to 0.12.17</li> <li>Include <code>bottle</code> as a vendored dependency to not be dependent on the long release cycles of <code>bottle</code></li> <li>Fix deprecation warnings to prepare for Python 3.8</li> <li>Allow matching multiline messages in <code>@listen_to</code> and <code>@respond_to</code> decorators (#178   by @seerickcode)</li> </ul>"},{"location":"changelog/#removed_7","title":"Removed","text":"<ul> <li>Breaking: drop support for Python 3.4 and 3.5</li> </ul>"},{"location":"changelog/#0180-2019-03-10","title":"0.18.0 - 2019-03-10","text":""},{"location":"changelog/#changed_28","title":"Changed","text":"<ul> <li>Bump <code>slackclient</code> from 1.3.0 to 1.3.1</li> <li>Bump <code>dill</code> from 0.2.8.2 to 0.2.9</li> <li>Bump <code>bottle</code> from 0.12.13 to 0.12.16</li> <li>Bump <code>redis</code> from 2.10.6 to 3.2.0</li> <li>Bump <code>Cython</code> from 0.28.5 to 0.29.6</li> </ul>"},{"location":"changelog/#0170-2018-11-10","title":"0.17.0 - 2018-11-10","text":""},{"location":"changelog/#added_16","title":"Added","text":"<ul> <li>Add support for bot aliases (#108   by @seerickcode)</li> </ul>"},{"location":"changelog/#0161-2018-09-28","title":"0.16.1 - 2018-09-28","text":""},{"location":"changelog/#changed_29","title":"Changed","text":"<ul> <li>Allow not only direct subclasses of MachineBasePlugin be plugins, but also deeper decendants (#95   by @gfreezy)</li> <li>Bump <code>slackclient</code> from 1.2.1 to 1.3.0 (#88)</li> </ul>"},{"location":"changelog/#0160-2018-09-06","title":"0.16.0 - 2018-09-06","text":""},{"location":"changelog/#added_17","title":"Added","text":"<ul> <li>Add HBase storage backend</li> </ul>"},{"location":"changelog/#0150-2018-09-03","title":"0.15.0 - 2018-09-03","text":""},{"location":"changelog/#added_18","title":"Added","text":"<ul> <li>Add optional keep-alive ping in background thread to keep the connection to Slack alive (#79   by @preludedrew)</li> </ul> <p>This helps when Slack Machine is running in environments that occasionally \"go to sleep\", such as Heroku</p>"},{"location":"changelog/#changed_30","title":"Changed","text":"<ul> <li>Bump <code>apscheduler</code> from 3.5.1 to 3.5.3</li> <li>Fix Python 3.7 builds by using Xenial distro</li> </ul>"},{"location":"changelog/#0140-2018-07-31","title":"0.14.0 - 2018-07-31","text":""},{"location":"changelog/#added_19","title":"Added","text":"<ul> <li>Add Python 3.7 support</li> </ul>"},{"location":"changelog/#changed_31","title":"Changed","text":"<ul> <li>Add support for configuring HTTP proxy for Slack client (#69   by @gfreezy)</li> </ul>"},{"location":"changelog/#0132-2018-07-04","title":"0.13.2 - 2018-07-04","text":""},{"location":"changelog/#changed_32","title":"Changed","text":"<ul> <li>Make HTTP server host &amp; port configurable (#64 by   @pirogoeth)</li> <li>Bump <code>dill</code> from 0.2.7.1 to 0.2.8.2</li> <li>Bump <code>slackclient</code> from 1.1.3 to 1.2.1</li> </ul>"},{"location":"changelog/#0131-2018-03-06","title":"0.13.1 - 2018-03-06","text":""},{"location":"changelog/#changed_33","title":"Changed","text":"<ul> <li>Mention webserver functionality in README</li> </ul>"},{"location":"changelog/#0130-2018-03-06-yanked","title":"0.13.0 - 2018-03-06 [YANKED]","text":"<p>:warning: NOTE: release was yanked due to lack of documentation</p>"},{"location":"changelog/#added_20","title":"Added","text":"<ul> <li>Add webserver functionality so plugins can have functions triggered by HTTP requests</li> </ul>"},{"location":"changelog/#changed_34","title":"Changed","text":"<ul> <li>Bump <code>slackclient</code> from 1.1.2 to 1.1.3</li> </ul>"},{"location":"changelog/#0122-2018-02-26","title":"0.12.2 - 2018-02-26","text":""},{"location":"changelog/#changed_35","title":"Changed","text":"<ul> <li>Bump <code>slackclient</code> from 1.1.0 to 1.1.2</li> <li>Memes plugin: support custom meme templates</li> </ul>"},{"location":"changelog/#fixed_21","title":"Fixed","text":"<ul> <li>Plugin help now properly distinguishes between robot or human help</li> </ul>"},{"location":"changelog/#0121-2018-01-26","title":"0.12.1 - 2018-01-26","text":""},{"location":"changelog/#fixed_22","title":"Fixed","text":"<ul> <li>Fix tests for new plugins</li> </ul>"},{"location":"changelog/#0120-2018-01-26","title":"0.12.0 - 2018-01-26","text":""},{"location":"changelog/#added_21","title":"Added","text":"<ul> <li>Add Google Image search plugin</li> <li>Add memes plugin based on Memegen</li> </ul>"},{"location":"changelog/#0110-2018-01-22","title":"0.11.0 - 2018-01-22","text":""},{"location":"changelog/#added_22","title":"Added","text":"<ul> <li>Add help feature so users can see what a bot can do based on documentation provided by plugin authors</li> </ul>"},{"location":"changelog/#0100-2018-01-21","title":"0.10.0 - 2018-01-21","text":""},{"location":"changelog/#added_23","title":"Added","text":"<ul> <li>Add optional plugin initialization</li> <li>Allow plugins to mark settings as required</li> </ul>"},{"location":"changelog/#changed_36","title":"Changed","text":"<ul> <li>Bump <code>apscheduler</code> from 3.4.0 to 3.5.1</li> </ul>"},{"location":"changelog/#090-2017-12-03","title":"0.9.0 - 2017-12-03","text":""},{"location":"changelog/#changed_37","title":"Changed","text":"<ul> <li>Bump <code>apscheduler</code> from 3.3.1 to 3.4.0</li> <li>Bump <code>slackclient</code> from 1.0.9 to 1.1.0</li> <li>WebAPI methods will return deserialized API responses (#14   by @pirogoeth)</li> </ul>"},{"location":"changelog/#removed_8","title":"Removed","text":"<ul> <li>Breaking: drop support for Python 3.3</li> </ul>"},{"location":"changelog/#080-2017-10-15","title":"0.8.0 - 2017-10-15","text":""},{"location":"changelog/#added_24","title":"Added","text":"<ul> <li>Add support for event listeners and emitting events for inter-plugin communication</li> </ul>"},{"location":"changelog/#070-2017-10-13","title":"0.7.0 - 2017-10-13","text":""},{"location":"changelog/#added_25","title":"Added","text":"<ul> <li>Add scheduling functionality to send messages and run plugin functions on a schedule</li> </ul>"},{"location":"changelog/#changed_38","title":"Changed","text":"<ul> <li>Refactor client classes to be singletons so they don't need to be persisted by APScheduler</li> <li>Add PyUp to automatically update dependencies</li> </ul>"},{"location":"changelog/#060-2017-09-14","title":"0.6.0 - 2017-09-14","text":""},{"location":"changelog/#added_26","title":"Added","text":"<ul> <li>Add pluggable plugin storage so plugins can store data</li> <li>Add 2 storage backends: in-memory and Redis</li> </ul>"},{"location":"changelog/#changed_39","title":"Changed","text":"<ul> <li>Drastically improve tests and increase coverage</li> </ul>"},{"location":"changelog/#050-2017-09-09","title":"0.5.0 - 2017-09-09","text":""},{"location":"changelog/#changed_40","title":"Changed","text":"<ul> <li>Finish documentation</li> </ul>"},{"location":"changelog/#040-2017-09-06","title":"0.4.0 - 2017-09-06","text":""},{"location":"changelog/#added_27","title":"Added","text":"<ul> <li>Document how to create plugins + plugin API</li> </ul>"},{"location":"changelog/#changed_41","title":"Changed","text":"<ul> <li>Decorators can now be used multiple times on the same function</li> </ul>"},{"location":"changelog/#030-2017-09-03","title":"0.3.0 - 2017-09-03","text":""},{"location":"changelog/#added_28","title":"Added","text":"<ul> <li>Basic documentation</li> </ul>"},{"location":"changelog/#020-2017-09-01","title":"0.2.0 - 2017-09-01","text":""},{"location":"changelog/#added_29","title":"Added","text":"<ul> <li>Add tests and CI</li> </ul>"},{"location":"changelog/#010-2017-08-29","title":"0.1.0 - 2017-08-29","text":"<p>First release. Rejoice! :wave:</p>"},{"location":"changelog/#added_30","title":"Added","text":"<ul> <li>A simple, yet powerful and extendable Slack bot framework</li> </ul>"},{"location":"migrating/","title":"Migrating plugins to async","text":"<p>As of v0.30.0 Slack Machine dropped support for the old backend based on the RTM API. As such, Slack Machine is now fully based on AsyncIO. This means plugins written before the rewrite to asyncio aren't supported anymore. This is a migration guide to get your old plugins working with the new version of Slack Machine.</p>"},{"location":"migrating/#await-all-slack-machine-plugin-functions","title":"Await all Slack Machine plugin functions","text":"<p>Any function from <code>MachineBasePlugin</code> and <code>Message</code> needs to be awaited now. This is as easy as prefixing your the function calls with the <code>await</code> keyword:</p> <pre><code>await self.say(\"#general\", \"Hello there baby!\")\n</code></pre>"},{"location":"migrating/#all-of-your-plugin-functions-need-to-be-async","title":"All of your plugin functions need to be async","text":"<p>Because you're awaiting methods from the Slack Machine plugin classes now, the functions you define in your own plugins, need to be async. This is as easy as prefixing your function definitions with the <code>async</code> keyword:</p> <pre><code>class MyPlugin(MachineBasePlugin):\n    @listen_to(r\"^hello\")\n    async def hello(self, msg):\n        msg.say(\"world\")\n</code></pre>"},{"location":"plugins/basics/","title":"Plugin Basics","text":"<p>Writing plugins for Slack Machine is easy. To show you how easy, we'll build and run a simple plugin from start to finish. To be able to follow this guide, you have to have installed and configured Slack Machine first!</p>"},{"location":"plugins/basics/#the-base-class-for-plugins","title":"The Base class for plugins","text":"<p>Plugins in Slack Machine are classes that subclass <code>MachineBasePlugin</code>. Inheriting from this class tells Slack Machine that we're dealing with a plugin. But that's not even the most exciting part! With this base class, your plugin immediately has a lot of functionality at its disposal that makes it super easy to do anything from talking to channels, responding to messages, sending DMs, and much more!</p>"},{"location":"plugins/basics/#the-decorators","title":"The decorators","text":"<p>Being able to talk in Slack is only half the story for plugins. The functions in your plugin have to be triggered somehow. Slack Machine provides decorators for that. You can decorate the functions in your plugin class to tell them what they should react to.</p> <p>As an example, let's create a cool plugin!</p>"},{"location":"plugins/basics/#step-1-creating-the-plugin","title":"Step 1: Creating the plugin","text":"<p>We're going to create a plugin that listens for The Answer, and responds in kind.</p> <p>In the root of your bot (where your <code>local_settings.py</code> lives), create a plugins folder. In it, create an <code>__init__.py</code> (so your plugins folder becomes a package) and a file named <code>hitchhikers.py</code>.</p> <p>Your folder structure should look like this:</p> <pre><code>\u251c\u2500\u2500 local_settings.py\n\u2514\u2500\u2500 plugins\n    \u251c\u2500\u2500 __init__.py\n    \u2514\u2500\u2500 hitchhikers.py\n</code></pre>"},{"location":"plugins/basics/#step-2-adding-the-code","title":"Step 2: Adding the code","text":"<p>First, we should import the <code>MachineBasePlugin</code> in our code, and the decorator to listen for specific messages. Then we can create our plugin class that includes a function that listens for The Answer, and responds to it:</p> <pre><code>from src.machine.plugins.base import MachineBasePlugin\nfrom src.machine import listen_to\nimport re\n\n\nclass UltimateQuestionPlugin(MachineBasePlugin):\n\n    @listen_to(regex=r\"^42$\")\n    async def question(self, msg):\n        await msg.say(\"You're telling me the Answer to the Ultimate Question of Life, the Universe and Everything, \",\n                      \"but I don't know the question :cry:\")\n</code></pre> <p>Tip</p> <p>As Slack-Machine is fully built on top of Python's excellent AsyncIO library, all of the functionality that Slack Machine offers (e.g. sending messages, adding reactions etc.) comes in the form of async functions, a.k.a. coroutines. This means that the plugin functions you define, have to be coroutines as well!</p> <p>This will take a while to get used to, but the reward is that Slack Machine is able to run your plugin functions concurrently.</p>"},{"location":"plugins/basics/#step-3-enabling-our-plugin","title":"Step 3: Enabling our plugin","text":"<p>Now we can enable our plugin in our configuration file. Your <code>local_settings.py</code> should look like this:</p> <pre><code>SLACK_APP_TOKEN = \"xapp-my-app-token\"\nSLACK_BOT_TOKEN = \"xoxb-my-bot-token\"\n\nPLUGINS = [\"machine.plugins.builtin.general.HelloPlugin\",\n           \"machine.plugins.builtin.general.PingPongPlugin\",\n           \"plugins.hitchhikers.UltimateQuestionPlugin\"]\n</code></pre>"},{"location":"plugins/basics/#step-4-run-that-bot","title":"Step 4: Run that bot!","text":"<p>To run your bot with the new plugin:</p> <pre><code>$ slack-machine\n</code></pre> <p>That's all there is to it!</p>"},{"location":"plugins/basics/#examples","title":"Examples","text":"<p>There is an example plugin that shows off many of the features of Slack Machine: Slack Machine Kitchensink Plugin</p>"},{"location":"plugins/block-kit-actions/","title":"Block Kit actions","text":"<p>Slack lets you build interactivity into your Slack app using Block Kit. Block Kit is a UI framework that lets you add interactive elements, such as buttons, input fields, datepickers etc. to surfaces like messages, modals and the App Home tab.</p> <p>Slack Machine makes it easy to listen to actions triggered by these interactive elements.</p>"},{"location":"plugins/block-kit-actions/#defining-actions","title":"Defining actions","text":"<p>When you're defining blocks for your interactive surfaces - either by providing a dict or by leveraging the models of the Slack SDK for Python - each of these blocks can be given a <code>block_id</code>. Within certain blocks, you can place block elements that are interactive. These interactive elements can be given an <code>action_id</code>. Given that one block can contain multiple action elements, each <code>block_id</code> can be linked to multiple <code>action_id</code>s.</p> <p>Whenever the user interacts with these elements, an event is sent to Slack Machine that contains the <code>block_id</code> and <code>action_id</code> corresponding to the block and element in which an action happened.</p>"},{"location":"plugins/block-kit-actions/#listening-to-actions","title":"Listening to actions","text":"<p>With the <code>@action</code> decorator you can define which plugin methods should be called when a certain action is triggered. The decorator takes 2 arguments: the <code>block_id</code> and the <code>action_id</code> that you want to listen to. Both arguments are optional, but one of them always needs to be set. Both arguments accept a <code>str</code> or <code>re.Pattern</code>. When a string is provided, the handler only fires upon an exact match, whereas with a regex pattern, you can have the handler fired for multiple matching <code>block_id</code>s or <code>action_id</code>s. This is convenient when you want one handler to process multiple actions within a block, for example.</p> <p>If only <code>action_id</code> or <code>block_id</code> is provided, the other defaults to <code>None</code>, which means it always matches.</p>"},{"location":"plugins/block-kit-actions/#parameters-of-your-action-handler","title":"Parameters of your action handler","text":"<p>Your block action handler will be called with a <code>BlockAction</code> object that contains useful information about the action that was triggered and the message or other surface in which the action was triggered.</p> <p>You can optionally add the <code>logger</code> argument to your handler get a logger that was enriched by Slack Machine</p> <p>The <code>BlockAction</code> contains various useful fields and properties about the action that was triggered and the context in which that happened. The <code>user</code> property corresponds to the user that triggered the action (e.g. clicked a button) and the <code>channel</code> property corresponds to the channel in which the message was posted where the action was triggered. This property is <code>None</code> when the action happened in a modal or the App Home tab. The <code>triggered_action</code> field holds information on the action that triggered the handler, including any value that was the result of the triggered action - such as the value of the button that was clicked. Lastly, the <code>payload</code> holds the complete payload the was received by Slack Machine when the action was triggered. Among other things, it holds the complete state of the interactive blocks within the message or modal where the action was triggered. This is especially useful when dealing with a submit button that was triggered, where you want to collect all the information in a form for example.</p>"},{"location":"plugins/block-kit-actions/#example","title":"Example","text":"<p>Let's imagine you're building a plugin for your Slack Machine bot that allows users to vote for what to have for lunch. You designed the following interaction:</p> <p></p> <p>Each lunch option has a vote button. Due to the way Block Kit works, to represent each option like this, they should be in their own section. Each section will have the description of the lunch option, the emoji and a button to vote. Sections are blocks, so we want to listen for actions within different blocks.</p> <p>This is what the handler could look like:</p> <pre><code>@action(action_id=None, block_id=re.compile(r\"lunch.*\", re.IGNORECASE))\nasync def lunch_action(self, action: BlockAction, logger: BoundLogger):\n    logger.info(\"Action triggered\", triggered_action=action.triggered_action)\n    food_block = [block for block in action.payload.message.blocks if block.block_id == action.triggered_action.block_id][0]\n    food_block_section = cast(blocks.SectionBlock, food_block)\n    food_description = str(food_block_section.text.text)\n    msg = f\"{action.user.fmt_mention()} has voted for '{food_description}'\"\n    await action.say(msg, ephemeral=False)\n</code></pre> <p>As you can see, we only care about the <code>block_id</code> here and not about the <code>action_id</code>. In the blocks that show the lunch options, <code>block_id</code>s would be set like <code>lunch_ramen</code>, <code>lunch_hamburger</code> etc.</p>"},{"location":"plugins/block-kit-actions/#responding-to-an-action","title":"Responding to an action","text":"<p>As you can see in the example, if you want to send a message to the user after an action was triggered, you can do so by calling the <code>say()</code> method on the action object your handler received from Slack Machine. This works just like any other way Slack provides for sending messages. You can include just text, but also rich content using Block Kit</p> <p>Info</p> <p>The <code>response_url</code> property is used by the <code>say()</code> method to send messages to a channel after receiving a command. It does so by invoking a Webhook using this <code>response_url</code> This is different from how <code>message.say()</code> works - which uses the Slack Web API.</p> <p>The reason for this is to keep consistency with how Slack recommends interacting with a user. For block actions, using the <code>response_url</code> is the recommended way</p> <p>Warning</p> <p>The <code>response_url</code> is only available when the action was triggered in a message - as opposed to in a modal or the App Home tab. The reason is of course that in the other two cases there is no channel to send the message to.</p>"},{"location":"plugins/interacting/","title":"How to interact","text":"<p>Slack Machine provides several convenient ways to interact with channels and users in your Slack workspace. To this end, two very similar sets of functions are exposed through two classes:</p>"},{"location":"plugins/interacting/#machinebaseplugin","title":"MachineBasePlugin","text":"The <code>MachineBasePlugin</code> class every plugin extends, provides methods to send messages to channels (public, private and DM), using the WebAPI, with support for rich messages/blocks/attachment. It also supports adding reactions to messages, pinning and unpinning messages, replying in-thread, sending ephemeral messages to a channel (only visible to 1 user), updating and deleting messages and much more."},{"location":"plugins/interacting/#message","title":"Message","text":"An instance of the <code>Message</code> class is automatically supplied to your plugin functions when using the <code>@respond_to</code> or <code>@respond_to</code> decorators. It has a similar set of methods as the <code>MachineBasePlugin</code> class, but without the need to manually specify the channel you want to talk to. It lets you send messages and reply to messages in the same channel the original message was received in. <p>It is recommended to use the passed-in <code>Message</code> object to interact with channels and users, whenever you use the <code>@respond_to</code> or <code>@respond_to</code> decorators, as this takes away the pain of having to manually target the right channels.</p> <p>For a detailed description of all the methods available to you, please read the api documentation. What follows are some examples of how you would respond in common scenarios.</p>"},{"location":"plugins/interacting/#responding-to-a-message","title":"Responding to a message","text":"If your plugin receives a message through the <code>@respond_to</code> or <code>@listen_to</code> decorators, the simplest way to reply is using <code>msg.reply()</code>. It takes 2 parameters: <p>text: the message you want to send</p> <p>in_thread: if Slack Machine should reply to the original message in-thread</p> <p><code>msg.reply()</code> will start the reply with a mention of the sender of the original message.</p> <p>Example:</p> <pre><code>@respond_to(r\"^I love you\")\nasync def spread_love(self, msg):\n    await msg.reply(\"I love you too!\")\n</code></pre> <p>If this function is triggered by a message @superbot I love you, sent by @john, the response will be: @john: I love you too!</p> <p><code>msg.reply()</code> will use the Slack WebAPI to send messages, which means you can send richly formatted messages using blocks and/or attachments.</p> <p>The underlying Python slack-sdk that Slack Machine uses, provides some convenience classes that can help with creating blocks or attachments. All Slack Machine methods that can be used to send messages, accept lists of <code>Block</code> objects and/or <code>Attachment</code> objects from the aforementioned convience classes.</p> This method has 2 extra parameters that unlock 2 extra features: <p>ephemeral: if <code>True</code>, the message will be visible only to the sender of the original message.</p> <p>in_thread: this will send the message in a thread instead of to the main channel</p> <p>There is 1 more method to respond to a message in the same channel: <code>msg.say()</code> is very similar to its <code>reply</code> counterpart, with the exception that it won't mention the sender of the original message.</p> <p>If you want to reply to the sender of the original message in a DM instead of in the original channel, you can use the <code>msg.reply_dm()</code> methods. This will open a DM convo between the sender of the original message and the bot (if it doesn't exist already) and send a message there. If the original message was already received in a DM channel, this is no different from using <code>reply()</code>.</p>"},{"location":"plugins/interacting/#message-properties","title":"Message properties","text":"The <code>Message</code> object your plugin function receives, has some convenient properties about the message that triggered the function: <p>sender: a <code>User</code> object with information about the sender, such as their <code>id</code> and <code>name</code></p> <p>channel: a Channel object with information about the channel the message was received in</p> <p>text: the contents of the original message</p>"},{"location":"plugins/interacting/#plugin-properties","title":"Plugin properties","text":"The <code>MachineBasePlugin</code> class every plugin extends, exposes some properties about your Slack workspace. These properties are not filled when your plugin is instantiated, but reflect the current status of the Slack client: <p>users: a dict of user ids and the associated <code>User</code> objects for all users that Slack Machine knows about. This is usually all the active users in your Slack workspace. This data structure is filled when Slack Machine starts and is automatically updated whenever a new user joins or the properties of a user change.</p> <p>channels: a dict of channel ids and the associated <code>User</code> objects for channels that Slack Machine knows about. This contains all the public channels in your Slack workspace, plus all private channels that your Slack Machine instance was invited to.</p>"},{"location":"plugins/interacting/#sending-messages-without-a-msg-object","title":"Sending messages without a msg object","text":"<p>There are situations in which you want to send messages to users/channels, but there is no original message to respond to. For example when implementing your own event listener using the <code>@process</code> decorator. In this case you can call functions similar as those described before, but from your plugin itself: <code>self.say()</code> and <code>self.send_dm()</code>.</p> <p>These behave similar to their <code>Message</code> counterparts, except that they require a channel id or object, or user id or object (in case of DM) to be passed in. You can use <code>find_channel_by_name()</code> to find the channel you want to send a message to.</p>"},{"location":"plugins/interacting/#scheduling-messages","title":"Scheduling messages","text":"<p>Sometimes you want to reply to a message, send a message to some channel, send a DM etc. but you don't want to do it now. You want to do it in the future. Slack Machine provides scheduled versions of many methods, both in the <code>MachineBasePlugin</code> all plugins extend from and in the <code>Message</code> object <code>@respond_to</code> and <code>@respond_to</code> functions receive. These methods can be recognized by their _scheduled prefix. They work almost the same as their regular counterparts, except that they receive 1 extra argument: a <code>datetime</code> object that tells Slack Machine when to send the message.</p> <p>Example:</p> <pre><code>@respond_to(r\"greet me in the future\")\nasync def future(self, msg):\n    await msg.say(\"command received!\")\n    in_10_sec = datetime.now() + timedelta(seconds=10)\n    await msg.reply_dm_scheduled(in_10_sec, \"A Delayed Hello!\")\n</code></pre> <p>This function will send a greeting 10 seconds after it has received a message: @superbot greet me in the future.</p> <p>Caveat</p> <p>You cannot schedule a reaction to a message. It doesn't make sense to react to a message in the future.</p> <p>For more information about scheduling message, have a look at the api documentation.</p>"},{"location":"plugins/interacting/#protecting-commands","title":"Protecting commands","text":"<p>Sometimes you may want to restrict certain commands in your bot, so they can only be invoked by certain users.</p> <p>To use these restrictions you must appoint one user to be the root user. For security reasons there can be only one root user, and it must be configured through <code>local_settings.py</code> or environment variables. That way you will never lose control over your bot.</p> <p>To enable all the role based features, your <code>local_settings.py</code> would look something like this:</p> <pre><code>SLACK_APP_TOKEN = \"xapp-my-app-token\"\nSLACK_BOT_TOKEN = \"xoxb-my-bot-token\"\nROOT_USER = \"0000007\"\nPLUGINS = [\n    'machine.plugins.builtin.admin.RBACPlugin',\n]\n</code></pre> <p>You can get the member ID from a user by going to their Slack profile, clicking more and selecting Copy member ID.</p> <p>If you wish to share the powers of root you can enable the RBAC admin plugin <code>machine.plugins.builtin.admin.RBACPlugin</code> and grant the admin role to users you trust.</p> <p>The RBAC plugin provides you with three new commands that lets you lookup, grant and revoke roles to users:</p> <ul> <li>@superbot who has role admin</li> <li>@superbot grant role admin to @trusted-user</li> <li>@superbot revoke role admin from @trusted-user.</li> </ul> <p>Now you can decorate certain functions in your plugin with the <code>@require_any_role</code> or <code>@require_all_roles</code> decorators to make them only usable by users with certain roles.</p> <p>Here is an example of a command that requires either the admin or channel role:</p> <pre><code>@respond_to(\n    r\"^say in\"\n    r\"\\s+&lt;#\\w+\\|(?P&lt;channel_name&gt;[^&gt;]+)&gt;\"\n    r\"\\s+(?P&lt;message&gt;.+)\"\n)\n@require_any_role([\"admin\", \"channel\"])\nasync def say_in_channel(self, msg, channel_name, message):\n    logging.info(channel_name)\n    await self.say(channel_name, message)\n</code></pre> <p>You can define as many roles as you want, any string without spaces is acceptable.</p>"},{"location":"plugins/interacting/#emitting-events","title":"Emitting events","text":"<p>Your plugin can emit arbitrary events that other plugins (or your own) can listen for. Events are a convenient mechanism for exchanging data between plugins and/or for a plugin to expose an api that other plugins can hook into. Emitting an event is done with <code>self.emit()</code>. You have to provide a name for the event you want to emit, so others can listen for an event by that name. You can optionally provide extra data as keyword arguments.</p> <p>Example:</p> <pre><code>@respond_to(r\"I have used the bathroom\")\nasync def broadcast_bathroom_usage(self, msg):\n    self.emit('bathroom_used', toilet_flushed=True)\n</code></pre> <p>You can read the events section to see how your plugin can listen for events.</p>"},{"location":"plugins/interacting/#using-the-slack-web-api-in-other-ways","title":"Using the Slack Web API in other ways","text":"<p>Sometimes you want to use Slack Web API in ways that are not directly exposed by <code>MachineBasePlugin</code>. In these cases you can use <code>self.web_client</code>. <code>self.web_client</code> references the <code>AsyncWebClient</code> object of the underlying Slack Python SDK. You should be able to call any Web API method with that client.</p>"},{"location":"plugins/listening/","title":"Listening for things","text":"<p>Slack Machine allows you to listen for various different things and respond to that. By decorating functions in your plugin using the decorators Slack Machine provides, you can tell Slack Machine to run those functions when something specific happens.</p>"},{"location":"plugins/listening/#listen-for-a-mention","title":"Listen for a mention","text":"<p>The <code>respond_to</code> decorator tells Slack Machine to listen for messages mentioning your bot and matching a specific pattern. Slack Machine will hear messages sent in any channel or private group it is a member of. For a message to trigger a function decorated by <code>@respond_to(...)</code>, the message has to start with a mention of your bot or with any alias the user configured using the <code>ALIASES</code> setting. The exception is direct messages sent to the bot, they don't have to include a mention to trigger <code>@respond_to</code>.</p> <code>@respond_to</code> takes 3 parameters: <p>regex (required): the regular expression Slack Machine should listen for. The regex pattern should not account for the mention of your bot, as Slack Machine will remove the mention before looking for a match. Slack Machine listens for any occurrence of the pattern in the message, so if you want to specifically match the whole message, you can anchor your pattern using the <code>^</code> and <code>$</code> symbols.</p> <p>flags (optional): can be used to pass flags for the regex matching as defined in the <code>re</code> module. By default, <code>re.IGNORECASE</code> is applied.</p> <p>handle_message_changed (optional): is used to configure if Slack Machine should trigger this function for messages that have been changed. By default, only new messages will trigger the decorated function.</p>"},{"location":"plugins/listening/#how-your-function-will-be-called","title":"How your function will be called","text":"<p>Your function will be called with a <code>Message</code> object that represents the message that triggered the function. It not only contains the message text itself, but also has many convenient methods for replying.</p> <p>Example:</p> <pre><code>@respond_to(r\"^I love you\")\nasync def spread_love(self, msg):\n    await msg.reply(\"I love you too!\")\n</code></pre> <p>The regex pattern can optionally contain named groups that will be captured and passed to your function as keyword arguments.</p> <p>Example:</p> <pre><code>@respond_to(r\"You deserve (?P&lt;num_stars&gt;\\d+) stars!\")\nasync def award(self, msg, num_stars):\n    stars_back = int(num_stars) + 1\n    await msg.reply(\"Well, you deserve {}!\".format(stars_back))\n</code></pre>"},{"location":"plugins/listening/#hear-any-message","title":"Hear any message","text":"<p>The <code>@listen_to</code> decorator works similar as the <code>@respond_to</code> decorator, but it will hear any message matching a pattern, without the bot being explicitly mentioned. <code>@listen_to</code> takes the same parameters as <code>@respond_to</code>.</p> <p>Example:</p> <pre><code>@listen_to(r\"go for it\")\n@listen_to(r\"go 4 it\")\nasync def go_for_it(self, msg):\n    await msg.say(\"https://a-z-animals.com/media/animals/images/original/gopher_2.jpg\")\n</code></pre> <p>As you can see, you can also apply the same decorator multiple times to a function, each time with different arguments. Of course, you can also combine different decorators on one function.</p>"},{"location":"plugins/listening/#more-flexibility-with-slack-events","title":"More flexibility with Slack events","text":"<p>If you want your bot to respond to other things than messages, you can do so using the <code>@process</code> decorator. <code>@process</code> requires an <code>event_type</code> as parameter and will trigger the decorated function any time an event of the specified type happens. It can listen to any Slack event that is supported by the Events API.</p> <p>The received event will be passed to your function.</p> <p>The following example will listen for the reaction_added event to know if a reaction was added to a message, and will match that reaction:</p> <pre><code>@process(\"reaction_added\")\nasync def match_reaction(self, event):\n    emoji = event[\"reaction\"]\n    channel = event[\"item\"][\"channel\"]\n    ts = event[\"item\"][\"ts\"]\n    await self.react(channel, ts, emoji)\n</code></pre> <p>As you can see, <code>@process</code> gives you a lot of flexibility by allowing you to process any event Slack Machine does not provide a specific decorator for.</p>"},{"location":"plugins/listening/#take-action-on-a-schedule","title":"Take action on a Schedule","text":"<p>Slack Machine can also run functions on a schedule, using the <code>@schedule</code> decorator. <code>@schedule</code> behaves like Linux/Unix Crontab, and receives similar parameters. You can specify on what schedule your function should be called. When your function is called, it will not receive any arguments except <code>self</code>, but you can of course call any <code>MachineBasePlugin</code> methods to send message and do other things.</p> <p>Example:</p> <pre><code>@schedule(hour=\"9-17\", minute=\"*/30\")\nasync def movement_reminder(self):\n    await self.say(\"general\", \"&lt;!here&gt; maybe now is a good time to take a short walk!\")\n</code></pre>"},{"location":"plugins/listening/#slack-machine-events","title":"Slack Machine events","text":"<p>Slack Machine can respond to events that are emitted by your plugin(s) or plugins of others, or events generated by parts of Slack Machine itself. You can use the <code>@on</code> decorator on a function to run that function whenever a certain event is emitted somewhere.</p> <p>Example:</p> <pre><code>@on(\"bathroom_used\")\nasync def call_cleaning_department(self, **kwargs):\n    await self.say(\"cleaning-department\", \"&lt;!here&gt; Somebody used the toilet!\")\n</code></pre> <p>This function will be called whenever the <code>bathroom_used</code> event is emitted somewhere.</p> <p>Some things to be aware of</p> <p>Event names are global, every plugin can emit and listen for the same events. This is by design, because this way, you can use events to exchange data between plugins. Events can be a way to expose a \"public API\" for plugins. But this can also mean your functions are unexpectedly triggered by events sent by other plugins, especially if the event names you choose are very generic.</p> <p>When emitting events, plugins can attach whatever variables they want to the event, and when listening for an event, your function will be called with whatever arguments were attached to the event when the event was emitted. It's therefor a good idea to always include <code>**kwargs</code> as a catch-all, otherwise your function could return an error when it's called with arguments that have not been explicitly defined.</p> <p>So what is this event system useful for? As mentioned in the above note, events can be used to communicate between plugins and/or for plugins to respond to events that happen within the core of Slack Machine. A good example of this, is the <code>unauthorized-access</code> event. This event will be emitted whenever someone tries to use a bot command protected by the <code>require_any_role</code> or <code>require_all_roles</code> decorators without having the right roles to issue that command. By listening to this event, your plugins can take action when this happens. The built-in RBAC plugin also listens for this event.</p> <p>You can read emitting events to learn how to emit events from your own plugins.</p>"},{"location":"plugins/misc/","title":"Miscellaneous stuff","text":"<p>This section contains some odds and ends that were not discussed in previous sections.</p>"},{"location":"plugins/misc/#plugin-initialization","title":"Plugin initialization","text":"<p>Plugins are initialized when Slack Machine starts. Because the <code>MachineBasePlugin</code> already has a constructor that is used to pass various things to the plugin instance at startup, it is advised not to provide a constructor for your plugin.</p> <p>If your plugin needs to initialize its own things at startup, you can override the <code>init()</code> method. This method will be called once when the plugin is initialized. It is no-op by default. If you choose to implement this method, make sure it is <code>async</code>. This allows you to use the async plugin API of Slack Machine to interact with Slack and also lets you use the plugin storage.</p> <p>When the <code>init()</code> methods of plugins are called, the underlying Slack client has already been initialized, so you should have full access to all Slack-related information, incl. a populated list of <code>users</code> and <code>channels</code></p>"},{"location":"plugins/misc/#logging","title":"Logging","text":"<p>Slack Machine uses structlog for logging. In your plugins, you can instantiate and use a logger as follows:</p> <pre><code>from structlog.stdlib import get_logger\n\nlogger = get_logger(__name__)\n\n\nasync def my_function():\n    logger.info(\"Running my function\", foo=42, bar=\"hello\")\n</code></pre>"},{"location":"plugins/misc/#logging-message-handler-invocations","title":"Logging message handler invocations","text":"<p>By default, Slack Machine will log anytime a Slack message triggers a handler in a plugin. This log statement will include the message that triggered the handler and the user id &amp; name of the user that posted the message.</p> <p>You can disable these log message by setting <code>LOG_HANDLED_MESSAGES</code> to <code>False</code> in your <code>local_settings.py</code></p>"},{"location":"plugins/misc/#using-loggers-provided-by-slack-machine-in-your-handler-functions","title":"Using loggers provided by Slack Machine in your handler functions","text":"<p>Structlog allows adding extra parameters as context. Slack Machine leverages this to bind the id and name of the user who sent a message to a logger as context variables whenever a message triggers a handler function. You can opt-in to using this logger, by adding a <code>logger</code> parameter to your handler function.</p> <pre><code>async def my_handler(msg, logger):\n    logger.info(\"my_handler invoked!\")\n</code></pre> <p>Slack Machine will automatically inject a logger with the right context variables into your handler. The example will produce a message like:</p> <pre><code>2022-10-21T14:29:05.639162Z [info] my_handler invoked! [example_plugin.my_plugin.MyPlugin.my_handler] filename=my_plugin.py func_name=my_handler lineno=5 user_id=U12345678 user_name=user1\n</code></pre> <p>This currently works for handler functions that are decorated with <code>respond_to</code>, <code>listen_to</code> or <code>command</code></p>"},{"location":"plugins/misc/#plugin-help-information","title":"Plugin help information","text":"<p>You can provide help text for your plugin and its commands by adding docstrings to your plugin class and its methods. The first line of the docstring of a plugin class will be used for grouping help information of plugin methods. This even extends beyond one class, ie. if multiple plugin classes have the same docstring (first line), the help information for the methods under those classes will be grouped together.</p> <p>The first line of the docstring of each plugin method can be used for specifying help information for that specific function. It should be in the format <code>command: help text</code>.</p> <p>The <code>machine.plugins.builtin.help.HelpPlugin</code> (enabled by default) will provide Slack users with the help information described above.</p>"},{"location":"plugins/modals/","title":"Modals","text":"<p>In Slack, modals are a way to ask users for input or display information in a dialog/popup-like form. Modals are a great way to collect information from users, display information, or confirm an action.</p> <p>Modals can only be triggered by actions the user takes. The most common types of user actions that can trigger a modal are:</p> <ul> <li>Shortcuts</li> <li>Slash Commands</li> <li>Block Kit interative components</li> </ul> <p>For each of these actions, Slack provides a <code>trigger_id</code> which can be used to open a modal. This needs to be done within 3 seconds of receiving the <code>trigger_id</code>. Slack Machine abstracts most of this away for you and lets you open modals from Slash Commands and Block Kit actions without having to worry about the <code>trigger_id</code>.</p>"},{"location":"plugins/modals/#defining-and-opening-modals","title":"Defining and opening modals","text":"<p>When you want to open a modal, you first need to define the view with the content you want to show. This view has some additional properties that define how the modal should behave. One important property is the <code>callback_id</code> which is used to identify the modal when it is submitted or closed.</p> <p>You can define a modal view in 2 ways:</p> <ul> <li>As a dict that conforms to the View schema</li> <li>By constructing a View   object from the Slack SDK for Python</li> </ul> <p>When you have defined the view, you can open the modal by calling the <code>open_modal</code> method on the <code>Command</code> object that is passed to your Slash Command handler or on the <code>BlockAction</code> object that is passed to your Block Kit action handler.</p>"},{"location":"plugins/modals/#listening-for-modal-interactions","title":"Listening for modal interactions","text":"<p>Once a modal is opened, the user can interact with the block kit elements within the modal, such as buttons, input fields, datepickers etc. When the user interacts with these elements, a block kit action can be triggered which lets you deal with input.</p> <p>Additionally, when the user submits the modal, this triggers a <code>view_submission</code> event that you can listen to with the <code>@modal</code> decorator. This decorator takes a <code>callback_id</code> as an argument, which is used to identify the modal that was submitted. The <code>callback_id</code> can be a <code>str</code> or a <code>re.Pattern</code>. When a string is provided, the handler only fires upon an exact match, whereas with a regex pattern, you can have the handler fired for multiple matching <code>callback_id</code>s. This is convenient when you want one handler to process multiple modals, for example.</p> <p>Unless you want to listen for changes to specific input fields - for example to update the modal in-place - it's probably easiest to use the <code>@modal</code> decorator and process the entire input upon modal submission.</p>"},{"location":"plugins/modals/#the-modal-handler-function","title":"The modal handler function","text":"<p>The handler function will be called with a <code>ModalSubmission</code> object that contains useful information about the modal that was submitted and the user that submitted it. The <code>ModalSubmission</code> object has a property <code>view</code> that contains the complete view that was submitted, including the state of the input fields of the modal. The object also has a <code>user</code> property that corresponds to the user that submitted the modal.</p> <p>You can optionally add the <code>logger</code> argument to your handler get a logger that was enriched by Slack Machine</p> <p>The <code>ModalSubmission</code> contains methods for updating the current modal view, pushing a new view on top of the current one or even opening a completely new modal.</p> <p>You can also send a message to the user that submitted the modal with the <code>send_dm</code> method.</p> <p>The modal handler function can be defined as a regular <code>async</code> function or a generator. When you define it as a generator, you can use the <code>yield</code> statement to:</p> <ul> <li>Update the modal view in-place</li> <li>Push a new view on top of the current one</li> <li>Close the current view (which is the default behavior when   nothing is yielded)</li> <li>Close all the views on the stack</li> <li>Display errors in the modal, which is useful when you want   to show validation errors to the user.</li> </ul> <p>Warning</p> <p>You must yield a response to Slack within 3 seconds of receiving the <code>view_submission</code> event. If you don't, Slack will show an error to the user.</p>"},{"location":"plugins/modals/#listening-for-modal-closures","title":"Listening for modal closures","text":"<p>Sometimes you want to know when a user closes a modal without submitting it. This can be useful to clean up resources or store the state of the modal for later continuation. You can listen for modal closures with the <code>@modal_closed</code> decorator. This decorator takes a <code>callback_id</code> as parameter and works the same way as the <code>@modal</code> decorator.</p> <p>The handler function will be called with a <code>ModalClosure</code> object that contains information about the modal that was closed. Just like the <code>ModalSubmission</code> object, the <code>ModalClosure</code> object has a <code>view</code> property that contains the complete view of the modal that was closed, including the state of the input fields. The object also has a <code>user</code> property that corresponds to the user that submitted the modal.</p> <p>You can send a message to the user that submitted the modal with the <code>send_dm</code> method.</p>"},{"location":"plugins/settings/","title":"Plugin Settings","text":"<p>All settings that are defined, either from the Slack Machine defaults or in <code>local_settings.py</code> are available to plugins through the <code>self.settings</code> field. This is a dictionary with all settings indexed by their name. Next to <code>local_settings.py</code>, users can also specify settings with environment variables. Slack Machine will automatically translate any environment variable with the format <code>SM_&lt;SETTING_NAME&gt;</code> to a setting with name <code>SETTING_NAME</code>, overriding a setting with the same name from <code>local_settings.py</code> or the default settings.</p> <p>So an environment variable <code>SM_SLACK_APP_TOKEN</code> will result in a setting <code>SLACK_APP_TOKEN</code>.</p> <p>Setting names are case insensitive.</p>"},{"location":"plugins/settings/#example-of-using-settings","title":"Example of using settings","text":"<p>When the <code>local_settings.py</code> looks like this:</p> <pre><code>SLACK_APP_TOKEN = \"xapp-my-app-token\"\nSLACK_BOT_TOKEN = \"xoxb-my-bot-token\"\nGREETING_PLUGIN_MY_GREETING = \"Bonjour\"\n</code></pre> <p>This can be used in a plugin, like this:</p> <pre><code>@respond_to(r\"Hello!\")\nasync def greeting(self, msg):\n    await msg.reply(f\"{self.settings['GREETING_PLUGIN_MY_GREETING']}, {msg.at_sender}!\")\n</code></pre> <p>The response to a message @superbot Hello! from @john, in this case would be: Bonjour, @john!</p>"},{"location":"plugins/settings/#required-settings","title":"Required settings","text":"<p>If your plugin requires one or more settings to be defined in order to work, you can mark them as required with the <code>@required_settings</code> decorator. This decorator takes a string or a list of strings as argument which can be one or more settings that are required by your plugin. Upon startup, Slack Machine will check if any of the settings that are marked as required by a plugin, have not been defined by the user. If it finds one or more missing settings, it will not load that particular plugin, and notify the user which settings are missing.</p> <p>The <code>@required_settings</code> decorator can be applied to a plugin class and/or its methods. Note that if any of the required settings are missing, the plugin will not load as a whole, so none of the methods will be registered.</p> <p>Example:</p> <pre><code>@required_settings([\"TODO_SERVICE_USERNAME\", \"TODO_SERVICE_PASSWORD\"])\nclass TodoPlugin(MachineBasePlugin):\n    ...\n</code></pre>"},{"location":"plugins/slash-commands/","title":"Slash Commands","text":"<p>Next to triggering Slack Machine by listening to messages that match a specific regular expression, you can also use Slash Commands in Slack Machine.</p>"},{"location":"plugins/slash-commands/#creating-a-slash-command","title":"Creating a Slash Command","text":"<p>To configure a Slash Command for your Slack App, you can follow the instructions in the official Slack documentation. As you will have likely followed the guide to using Slack Machine, you propbably have already defined a Slack App. This is what you need to do next:</p> <ol> <li>Go to your app's management dashboard</li> <li>Click your Slack App</li> <li>Go to Slash Commands in the navigation menu</li> <li>Click the Create New Command button and follow the instructions</li> </ol>"},{"location":"plugins/slash-commands/#using-the-app-manifest","title":"Using the App manifest","text":"<p>If you used the example App manifest when creating your Slack App, you can also adjust that to include the Slash Commands you want to define. You can add it under <code>features</code> as follows:</p> <pre><code>features:\n  bot_user:\n    display_name: My Bot\n    always_online: false\n  slash_commands:\n    - command: /hello\n      description: Say hello\n      usage_hint: \"[whatever else you want to say]\"\n      should_escape: false\n</code></pre>"},{"location":"plugins/slash-commands/#defining-your-slash-command-in-code","title":"Defining your Slash Command in code","text":"<p>The next step is to use the <code>@command</code> decorator on the function that should be triggered when the user uses the Slash Command you defined. The decorator takes only 1 parameter: the slash command that should trigger the decorated function. It should be the same as the Slash Command you just defined in the App dashboard.</p> <p>This is what a decorated command handler typically looks like:</p> <pre><code>@command(\"/hello\")\nasync def hello(self, command):\n    print(f\"I just received the following command: {command.command} with text {command.text}\")\n    await command.say(\"I like greetings!\")\n</code></pre>"},{"location":"plugins/slash-commands/#parameters-of-your-command-handler","title":"Parameters of your command handler","text":"<p>Your command handler will be called with a <code>Command</code> object that contains useful information about the slash command invocation. The most important property is probably <code>text</code>, which contains any additional text that was passed when the slash command was used.</p> <p>You can optionally add the <code>logger</code> argument to your handler get a logger that was enriched by Slack Machine</p>"},{"location":"plugins/slash-commands/#responding-to-a-command","title":"Responding to a command","text":"<p>Responding to Slash Commands is a timely business. As explained in the official documentation, the receipt of the slash command payload has to be acknowledged. This has to happen within 3 seconds, or Slack will return an error to the user. To make your life easy, Slack Machine will handle all of this.</p> <p>If you want to send a message to the user after a slash command was invoked, you can do so by calling the <code>say()</code> method on the command object your handler received from Slack Machine. This works just like any other way Slack provides for sending messages. You can include just text, but also rich content using Block Kit</p> <p>Info</p> <p>The <code>response_url</code> property is used by the <code>say()</code> method to send messages to a channel after receiving a command. It does so by invoking a Webhook using this <code>response_url</code> This is different from how <code>message.say()</code> works - which uses the Slack Web API.</p> <p>The reason for this is to keep consistency with how Slack recommends interacting with a user. For commands, using the <code>response_url</code> is the recommended way</p> <p>If you read the aforementioned documentation on responding to commands carefully, you'll notice that as part of acknowleding the receipt of a command payload, you can return a response to the user (which has to happen in 3 seconds). This is different from the <code>command.say()</code> method, which does not have any timing requirements. Slack Machine supports returning an immediate response by turning your command handler into a generator and returning an immediate response through <code>yield</code>:</p> <pre><code>@command(\"/hello-again\")\nasync def hello_again(self, command):\n    print(f\"I just received the following command: {command.command} with text {command.text}\")\n    # this is sent as part of the initial payload acknowledgement\n    yield \"This will be returned immediately to the user\"\n    # this is less time-sensitive\n    await command.say(\"This will be sent after the initial acknowledgement\")\n</code></pre>"},{"location":"plugins/slash-commands/#opening-modals","title":"Opening modals","text":"<p>The <code>Command</code> object that your handler receives, contains an extra piece of information you can use to trigger more varied reponses: the <code>trigger_id</code> The <code>trigger_id</code> can used specifically to trigger modal responses. You don't have to worry about the <code>trigger_id</code> and instead can just call the <code>open_modal</code> method on the <code>Command</code> object to open a modal.</p>"},{"location":"plugins/storage/","title":"Storage","text":"<p>Slack Machine provides persistent storage that can easily be accessed from plugins through <code>self.storage</code>. This field contains an instance of <code>PluginStorage</code>, which lets you store, retrieve and remove values by key, check for the existence of a key and get information about the current size of the underlying storage.</p> <p>The <code>PluginStorage</code> class interfaces with whatever storage backend Slack Machine is configured with. You can read more about the available storage backends in the user guide.</p> <p>Example:</p> <pre><code>@respond_to(r\"store (?P&lt;text&gt;.*) under (?P&lt;key&gt;\\w+)\")\nasync def store(self, msg, text, key):\n    await self.storage.set(key, text)\n    await msg.say(f\"'{text}' stored under {key}!\")\n\n@respond_to(r\"retrieve (?P&lt;key&gt;\\w+)\")\nasync def retrieve(self, msg, key):\n    data = await self.storage.get(key)\n    if data:\n        await msg.say(f\"'{data}' retrieved from &lt;{key}&gt;!\")\n    else:\n        await msg.say(\"Key not found!\")\n\n@respond_to(r\"delete (?P&lt;key&gt;\\w+)\")\nasync def delete(self, msg, key):\n    await self.storage.delete(key)\n    await msg.say(f\"data in &lt;{key}&gt; deleted!\")\n\n@respond_to(r\"does (?P&lt;key&gt;\\w+) exist?\")\nasync def exists(self, msg, key):\n    if await self.storage.has(key):\n        await msg.say(f\"&lt;{key}&gt; exists.\")\n    else:\n        await msg.say(f\"&lt;{key}&gt; does not exist!\")\n\n@respond_to(r\"size\")\nasync def size(self, msg):\n    human_size = await self.storage.get_storage_size_human()\n    await msg.say(\"storage size: {human_size}\")\n</code></pre>"},{"location":"plugins/storage/#shared-vs-non-shared","title":"Shared vs non-shared","text":"<p>By default, when you store, retrieve and remove data by key, Slack Machine will automatically namespace the keys you use with the fully qualified classname of the plugin the storage is used from. This is done to prevent plugins from changing or even deleting each others data. So when you do this:</p> <pre><code># resides in module my.plugin.package\nclass MyPlugin:\n    async def some_function():\n        await self.storage.set(\"my-key\", \"my-data\")\n</code></pre> <p>Slack Machine will send the key <code>my.plugin.package.MyPlugin:my-key</code> to the storage backend.</p> <p>You can override this behaviour by setting the <code>shared</code> parameter to <code>True</code> when calling a storage related function that requires a key as parameter. This keep the key global (ie. non-namespaced). This is useful when you want to share data between plugins. Use this feature with care though, as you can destroy data that belongs to other plugins!</p>"},{"location":"plugins/storage/#implementing-your-own-storage-backend","title":"Implementing your own storage backend","text":"<p>You can implement your own storage backend by subclassing [<code>MachineBaseStorage</code>][machine.storage.backends.base. MachineBaseStorage]. You only have to implement a couple of methods, and you don't have to take care of namespacing of keys, as Slack Machine will do that for you.</p>"},{"location":"user/install/","title":"Installation","text":"<p>This part of the documentation helps you install Slack Machine with the least amount of friction, or the most amount of flexibility.</p>"},{"location":"user/install/#installing-the-easy-way-with-pip","title":"Installing the easy way with pip","text":"<p>Slack Machine is published to the Python package index so you can easily add Slack Machine to your uv project by running:</p> <pre><code>uv add slack-machine\n</code></pre> <p>or add it to your Poetry project:</p> <pre><code>poetry add slack-machine\n</code></pre> <p>Lastly, you can install it using pip (not recommended):</p> <pre><code>$ pip install slack-machine\n</code></pre> <p>It is strongly recommended that you install <code>slack-machine</code> inside a virtual environment!</p>"},{"location":"user/install/#installing-from-source","title":"Installing from source","text":"<p>If you are adventurous, want to modify the core of your Slack Machine instance and want maximum flexibility, you can also install from source. This way, you can enjoy the latest and greatest!</p> <p>You can either clone the public repository:</p> <pre><code>git clone git://github.com/DonDebonair/slack-machine.git\n</code></pre> <p>Or, download the tarball:</p> <pre><code>curl -OL https://github.com/DonDebonair/slack-machine/tarball/main\n</code></pre> <p>Optionally, zipball is also available (for Windows users).</p> <p>Once you have a copy of the source, you can embed it in your own Python package, or install it into your virtualenv easily:</p> <pre><code>cd slack-machine\npip install .\n</code></pre>"},{"location":"user/intro/","title":"Introduction","text":""},{"location":"user/intro/#philosophy","title":"Philosophy","text":"<p>Slack Machine is a simple, yet powerful and extendable bot framework &amp; platform for Slack.</p> <p>Slack Machine should be:</p> <ul> <li>Full-featured</li> <li>Easy to extend</li> <li>Easy to contribute to (the core)</li> <li>Fun to use</li> <li>Fun to extend</li> </ul> <p>My dream would be, that a community springs up around Slack Machine, that produces a myriad of useful plugins that are easy to install and use.</p>"},{"location":"user/intro/#non-goals","title":"Non-goals","text":"<p>These are non-goals for me at the moment, but that might change in the future:</p> <ul> <li>Support for other backends than Slack</li> <li>Built-in AI. At least not in the core, although whatever intelligence developers put into their plugins, is cool of   course</li> </ul>"},{"location":"user/intro/#why-slack-machine-was-built","title":"Why Slack Machine was built","text":"<p>I love Slack, and I use it on a daily basis, both at work and in my private life. Due to the powerful APIs that Slack exposes, it's not only great for chatting, but also for automation. We developers love automation, so I wanted to add some of that to the Slack workspaces I'm a member of. Obviously, there have already been many attempts to leverage this extensibility of Slack, considering the many apps/bots/bot frameworks/chatops frameworks out there.</p> <p>Why build another one?!</p> <p>All of the options that I could find, were inadequate for some reason. I've used Hubot a lot in the past, but Coffeescript (or Javascript for that matter), just doesn't click with me. I personally feel that Python is a great language to tackle this sort of problem, so I started looking for Slack bots written in Python. At the time I created Slack Machine, these were the options I could find:</p> <ul> <li>python-rtmbot: Created by the Slack team, this bot is very barebones and   exposes a very low-level plugin API. This makes it hard/tedious to write plugins for it. It is not mainainted anymore</li> <li>slackbot: Has a more high-level plugin API, which is built on the right   ideas in terms of developer friendlyness. But it was lacking some features that I want in a bot (among other   things: scheduling, persistent storage and a help-feature), and I found that the plugin architecture didn't allow for   proper plugin organisation. This made me decide not to contribute, and instead start my own project.</li> <li>Will: This was originally not a bot for Slack, but for Hipchat, but it has support   for Slack (and other backends) since a couple of years. I'm including it. Will came closests to what I want, both   in terms of feature set and plugin API. At the time I created Slack Machine, it only supported HipChat and I   personally found the code quite hard to read. I also feel that a framework supporting many different chat   platforms is bound to serve the lowest common denominator. This will lead to suboptimal quality.</li> </ul> <p>So, in the end I decided that writing a full-featured, easy-to-extend Slack bot, written in Python, would be cool new project to take up.</p> <p>Note</p> <p>The above was written 4 years ago and a lot has changed since then. The Slack team has created Bolt, a bot framework that is quite similar to Slack Machine. There are still differences in the way code is organized and I feel that Slack Machine is better suited to build complex Slack bots with in which code is organized in multiple plugins. This is currently not supported by Bolt</p> <p>I plan to keep maintaining Slack Machine and bringing it up to date with current best practices, so that the features and developer experience are on-par with or better than Bolt</p>"},{"location":"user/intro/#acknowledgements","title":"Acknowledgements","text":"<p>Slack Machine owes a great deal of debt to the aforementioned packages. Parts of the API of Slack Machine were inspired by those packages, and I was at a great advantage while building Slack Machine because I was able to look at existing code to get an idea on how to approach certain problems. While obviously I'd like to think I have improved upon my inspirations, Slack Machine couldn't have existed without them.</p>"},{"location":"user/intro/#slack-machine-license","title":"Slack Machine License","text":"<p>MIT License</p> <p>Copyright (c) 2018 Daan Debie</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"user/usage/","title":"Using Slack Machine","text":"<p>Once you have installed Slack Machine, configuring and starting your bot is easy:</p> <ol> <li>Create a directory for your Slack Machine bot: <code>mkdir my-slack-bot &amp;&amp; cd my-slack-bot</code></li> <li>Add a <code>local_settings.py</code> file to your bot directory: <code>touch local_settings.py</code></li> <li>Create a new app in Slack: https://api.slack.com/apps</li> <li>Choose to create an app from an App manifest</li> <li> <p>Copy/paste the following manifest:</p> manifest.yaml<pre><code>display_information:\n  name: Slack Machine\nfeatures:\n  bot_user:\n    display_name: Slack Machine\n    always_online: false\noauth_config:\n  scopes:\n    bot:\n      - app_mentions:read\n      - channels:history\n      - channels:join\n      - channels:read\n      - chat:write\n      - chat:write.public\n      - emoji:read\n      - groups:history\n      - groups:read\n      - groups:write\n      - im:history\n      - im:read\n      - im:write\n      - mpim:history\n      - mpim:read\n      - mpim:write\n      - pins:read\n      - pins:write\n      - reactions:read\n      - reactions:write\n      - users:read\n      - users:read.email\n      - channels:manage\n      - chat:write.customize\n      - dnd:read\n      - files:read\n      - files:write\n      - links:read\n      - links:write\n      - metadata.message:read\n      - usergroups:read\n      - usergroups:write\n      - users.profile:read\n      - users:write\nsettings:\n  event_subscriptions:\n    bot_events:\n      - app_home_opened\n      - app_mention\n      - channel_archive\n      - channel_created\n      - channel_deleted\n      - channel_id_changed\n      - channel_left\n      - channel_rename\n      - channel_unarchive\n      - group_archive\n      - group_deleted\n      - group_left\n      - group_rename\n      - group_unarchive\n      - member_joined_channel\n      - member_left_channel\n      - message.channels\n      - message.groups\n      - message.im\n      - message.mpim\n      - reaction_added\n      - reaction_removed\n      - team_join\n      - user_change\n      - user_profile_changed\n      - user_status_changed\n  interactivity:\n    is_enabled: true\n  org_deploy_enabled: false\n  socket_mode_enabled: true\n  token_rotation_enabled: false\n</code></pre> </li> <li> <p>Add the Slack App and Bot tokens to your <code>local_settings.py</code> like this:</p> local_settings.py<pre><code>SLACK_APP_TOKEN = \"xapp-my-app-token\"\nSLACK_BOT_TOKEN = \"xoxb-my-bot-token\"\n</code></pre> </li> <li> <p>Start the bot with <code>slack-machine</code></p> </li> <li>...</li> <li>Profit!</li> </ol>"},{"location":"user/usage/#configuring-slack-machine","title":"Configuring Slack Machine","text":"<p>All the configuration for your bot lives in the <code>local_settings.py</code> in the root of your bot directory. The core of Slack Machine, and the most of the built-in plugins, only need a <code>SLACK_APP_TOKEN</code> and <code>SLACK_BOT_TOKEN</code> to function.</p> <p>You can override the log level by setting <code>LOGLEVEL</code>. By default this is set to <code>\"ERROR\"</code>.</p> <p>Warning</p> <p>If you set the <code>LOGLEVEL</code> to <code>DEBUG</code>, all events your Slack App is subscribed to, will be logged.</p> <p>If you want to use Slack Machine behind a proxy, you can set <code>HTTP_PROXY</code>.</p>"},{"location":"user/usage/#using-environment-variables-for-configuration","title":"Using environment variables for configuration","text":"<p>For some configuration, it can be a security consideration not to store them in your source code (i.e. <code>local_settings.py</code>) Slack Machine allows you to provide any setting - both built-in and for plugins - as environment variables. This is done by prefixing the setting name with <code>SM_</code>. Example: <code>SM_SLACK_APP_TOKEN</code> and <code>SM_SLACK_BOT_TOKEN</code> as environment variable can be used to set the <code>SLACK_APP_TOKEN</code> and <code>SLACK_BOT_TOKEN</code> settings instead of having to put it in the <code>local_settings.py</code>.</p> <p>This way you can follow the 12 Factor app best practices to configure your bot!</p>"},{"location":"user/usage/#setting-aliases","title":"Setting aliases","text":"<p>The <code>ALIASES</code> configuration setting allows the bot to respond to a trigger symbol instead of a direct @botname.</p> <p>Example:</p> <p>If <code>ALIASES='!,%'</code> was set in <code>local_settings.py</code> then the bot would respond to the following phrases:</p> <pre><code>@botname release the hounds\n!release the hounds\n%release the hounds\n</code></pre>"},{"location":"user/usage/#enabling-plugins","title":"Enabling plugins","text":"<p>Slack Machine comes with a few simple built-in plugins:</p> <ul> <li>HelloPlugin: responds in kind when users greet the bot with   \"hello\" or \"hi\" (only when the bot is mentioned)</li> <li>PingPongPlugin: responds to \"ping\" with \"pong\" and vice   versa (listens regardless of mention)</li> <li>EchoPlugin: replies to any message the bot hears, with exactly   the same message. The bot will reply to the same channel the   original message was heard in</li> <li>HelpPlugin: responds to \"help\" with a list of all available commands and how they work. You can use \"robot   help\" to learn the regexes that are used to match commands.</li> <li>MemePlugin: lets the user generate memes based on templates and captions Uses Memegen</li> <li>ImageSearchPlugin: lets users search images and gifs using Google Custom Search (requires setting up a   Programmable Search Engine in Google and adding the   search engine id as <code>GOOGLE_CSE_ID</code> and a Google API key as <code>GOOGLE_API_KEY</code>)</li> <li>RBACPlugin: lets admins assign, revoke and list user roles. Is used when you want to   protect commands</li> </ul> <p>By default, HelloPlugin and PingPongPlugin are enabled.</p> <p>You can specify which plugins Slack Machine should load, by setting the <code>PLUGINS</code> variable in <code>local_settings.py</code> to a list of fully qualified classes or modules that contain plugins. You can either point to a plugin class directly, or to a module containing one or more plugins.</p> <p>For example, to enable most of the built-in Slack Machine plugins, your <code>local_settings.py</code> would look like this:</p> <pre><code>SLACK_APP_TOKEN = \"xapp-my-app-token\"\nSLACK_BOT_TOKEN = \"xoxb-my-bot-token\"\nPLUGINS = [\n    \"machine.plugins.builtin.general.PingPongPlugin\",\n    \"machine.plugins.builtin.general.HelloPlugin\",\n    \"machine.plugins.builtin.debug.EchoPlugin\",\n    \"machine.plugins.builtin.fun.memes.MemePlugin\",\n    \"machine.plugins.builtin.help.HelpPlugin\",\n]\n</code></pre> <p>Or is you want import them by the modules they're in:</p> <pre><code>SLACK_APP_TOKEN = \"xapp-my-app-token\"\nSLACK_BOT_TOKEN = \"xoxb-my-bot-token\"\nPLUGINS = [\n    \"machine.plugins.builtin.general\",\n    \"machine.plugins.builtin.debug\",\n    \"machine.plugins.builtin.help\",\n    \"machine.plugins.builtin.fun.memes\",\n]\n</code></pre> <p>Slack Machine can load any plugin that is on the Python path. This means you can load any plugin that is installed in the same virtual environment you installed Slack Machine in. And as a convenience, Slack Machine will also add the directory you start Slack Machine from, to your Python path.</p>"},{"location":"user/usage/#choosing-storage","title":"Choosing storage","text":"<p>Slack Machine provides persistent storage, which can be used by plugins to store data of any kind. Slack Machine supports different backends for storage, so you can choose one that best fits your needs and existing infrastructure. You can configure which backend to use, by setting the <code>STORAGE_BACKEND</code> variable in <code>local_settings.py</code> to the fully qualified class of the chosen storage backend.</p> <p>Out of the box, Slack Machine provides 4 options for storage backend:</p>"},{"location":"user/usage/#in-memory-default","title":"in-memory (default)","text":"<p>This backend will store all data in-memory, which is great for testing because it doesn't have any external dependencies. Does not persist data between restarts</p> <p>Class: <code>machine.storage.backends.memory.MemoryStorage</code></p>"},{"location":"user/usage/#redis","title":"Redis","text":"<p>Install with: <code>uv add 'slack-machine[redis]'</code></p> <p>This backend stores data in Redis. Redis is a very fast key-value store that is super easy to install and operate. This backend is recommended, because it will persist data between restarts. The Redis backend requires you to provide a URL to your Redis instance by setting the <code>REDIS_URL</code> variable in <code>local_settings.py</code>. The URL should have the following format:</p> <pre><code>`redis://&lt;host&gt;:&lt;port&gt;[/&lt;db&gt;]`\n</code></pre> <p>Where <code>db</code> is optional and sets the database number (0 by default)</p> <p>Optional parameters:</p> <ul> <li><code>REDIS_MAX_CONNECTIONS</code>: maximum number of connections Slack   Machine can make to your Redis instance</li> <li><code>REDIS_KEY_PREFIX</code>: the prefix Slack Machine uses for keys (<code>SM</code>   by default, so \"key1\" gets stored under <code>SM:key1</code>)</li> </ul> <p>Class: <code>machine.storage.backends.redis.RedisStorage</code></p>"},{"location":"user/usage/#dynamodb","title":"DynamoDB","text":"<p>Install with: <code>uv add 'slack-machine[dynamodb]'</code></p> <p>This backend stores data in DynamoDB. DynamoDB is a managed NoSQL datastore on AWS that, among other things, allows for easy persistance of objects by key. The DynamoDB backend requires either a set of valid AWS account credentials, or a locally running DynamoDB test bed, such as the one included in localstack. This backend requires the environment variables or path-based AWS credentials that are normally used to access AWS services. The following are optional parameters that can be set in your <code>local_settings.py</code> or <code>SM_</code> environment variable slack-machine settings:</p> <p>Optional parameters:</p> <ul> <li><code>DYNAMODB_ENDPOINT_URL</code>: specifies an optional alternate endpoint, for local bot testing</li> <li><code>DYNAMODB_KEY_PREFIX</code>: an optional prefix to use within the key lookup. Defaults to <code>SM:</code></li> <li><code>DYNAMODB_TABLE_NAME</code>: specifies the table to use in DynamoDB. Defaults to <code>slack-machine-state</code></li> <li><code>DYNAMODB_CREATE_TABLE</code>: optionally -create- the table to be used in DynamoDB. Defaults to <code>False</code></li> <li><code>DYNAMODB_CLIENT</code>: if custom configuration is needed for the DynamoDB client, an optional   <code>aioboto3</code> resource can be specified here</li> </ul> <p>Class: <code>machine.storage.backends.dynamodb.DynamoDBStorage</code></p>"},{"location":"user/usage/#sqlite","title":"SQLite","text":"<p>Install with: <code>uv add 'slack-machine[sqlite]'</code></p> <p>This backend stores data in SQLite. SQLite is a C library that provides a lightweight disk-based database that doesn\u2019t require a separate server process and allows accessing the database using a non-standard variant of the SQL query language.</p> <p>The SQLite backend requires you to provide a filename that will be used to store the data by setting the <code>SQLITE_PATH</code> variable in <code>local_settings.py</code>. The filename can be relative or absolute:</p> <pre><code>`SQLITE_PATH: /path/to/slack-machine.db`\n</code></pre> <p>Class: <code>machine.storage.backends.sqlite.SQLiteStorage</code></p> <p>So if, for example, you want to configure Slack Machine to use Redis as a storage backend, with your Redis instance running on localhost on the default port, you would add this to your <code>local_settings.py</code>:</p> <pre><code>STORAGE_BACKEND = 'machine.storage.backends.redis.RedisStorage'\nREDIS_URL = redis://localhost:6379'\n</code></pre> <p>That's all there is to it!</p>"}]}