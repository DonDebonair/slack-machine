# -*- coding: utf-8 -*-

import asyncio
import re

from loguru import logger

from machine.singletons import Slack
from machine.message import Message
from machine.slack import MessagingClient


class EventDispatcher:
    def __init__(self, plugin_actions, settings=None):
        self._client = Slack.get_instance()
        self._plugin_actions = plugin_actions
        alias_regex = ""
        if settings and "ALIASES" in settings:
            logger.info("Setting aliases to {}".format(settings["ALIASES"]))
            alias_regex = "|(?P<alias>{})".format(
                "|".join([re.escape(s) for s in settings["ALIASES"].split(",")])
            )
        self.RESPOND_MATCHER = re.compile(
            r"^(?:<@(?P<atuser>\w+)>:?|(?P<username>\w+):{}) ?(?P<text>.*)$".format(
                alias_regex
            ),
            re.DOTALL,
        )

    def _event_callback(self, event_type: str):
        """ Returns a closured coroutine that dispatches the
            given event type to the event handler function
        """

        async def dispatch(*, data: dict, **kwargs):
            return await self.handle_event(event_type, data=data, **kwargs)

        return dispatch

    def start(self):
        default_events = {"message", "pong"}
        # `python-slackclient` no longer allows us to inject the firehose of events -
        # we have to register a "type" of event we want to process to receive it.
        registered_events = set(self._plugin_actions.get("process", []).keys())
        events = default_events | registered_events

        logger.debug(f"Registering for events: {events}")

        for event in events:
            self._client.rtm.on(event=event, callback=self._event_callback(event))

    async def handle_event(self, event_type: str, *, data: dict, **kwargs):
        # The bot should never react to an event generated by itself
        if "user" in data and data["user"] == self._get_bot_id():
            return

        # Basic dispatch based on event type
        if event_type in self._plugin_actions["process"]:
            handlers = []
            for action in self._plugin_actions["process"][event_type].values():
                handlers.append(action["function"](data))

            await asyncio.gather(*handlers)

        # Handle message listeners
        if event_type == "message":
            respond_to_msg = self._check_bot_mention(data)
            if respond_to_msg:
                listeners = self._find_listeners("respond_to")
                await self._dispatch_listeners(listeners, respond_to_msg)
            else:
                listeners = self._find_listeners("listen_to")
                await self._dispatch_listeners(listeners, data)

        elif event_type == "pong":
            logger.debug("Server Pong!")

    def _find_listeners(self, type):
        return [action for action in self._plugin_actions[type].values()]

    @staticmethod
    def _gen_message(event, plugin_class_name):
        return Message(MessagingClient(), event, plugin_class_name)

    def _get_bot_id(self):
        return self._client.login_data["self"]["id"]

    def _get_bot_name(self):
        return self._client.login_data["self"]["name"]

    def _check_bot_mention(self, event):
        full_text = event.get("text", "")
        channel = event["channel"]
        bot_name = self._get_bot_name()
        bot_id = self._get_bot_id()

        at_response = self.RESPOND_MATCHER.match(full_text)

        if channel[0] == "C" or channel[0] == "G":
            if not at_response:
                return None

            matches = at_response.groupdict()

            atuser = matches.get("atuser")
            username = matches.get("username")
            text = matches.get("text")
            alias = matches.get("alias")

            if alias:
                atuser = bot_id

            if atuser != bot_id and username != bot_name:
                # a channel message at other user
                return None

            event["text"] = text
        else:
            if at_response:
                event["text"] = at_response.groupdict().get("text", None)

        return event

    async def _dispatch_listeners(self, listeners, event):
        handlers = []
        for l in listeners:
            matcher = l["regex"]
            match = matcher.search(event.get("text", ""))
            if match:
                message = self._gen_message(event, l["class_name"])
                handlers.append(l["function"](message, **match.groupdict()))

        if handlers:
            await asyncio.gather(*handlers)
